<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>skrt.image module &mdash; Scikit-rt 0.5.12 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="skrt.multi module" href="skrt.multi.html" />
    <link rel="prev" title="skrt.dose module" href="skrt.dose.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Scikit-rt
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Help topics:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="support.html">Documentation and support</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Scikit-rt by examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage and data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="images.html">Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="structures.html">Regions of interest (ROIs) and structure sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="patients_and_studies.html">Patients and studies</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulation.html">Synthetic data</a></li>
<li class="toctree-l1"><a class="reference internal" href="registration.html">Image registration</a></li>
<li class="toctree-l1"><a class="reference internal" href="keyboard_shortcuts.html">Keyboard shortcuts for pop-out interactive viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="docker.html">Scikit-rt with Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="kubernetes.html">Scikit-rt with Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="legacy.html">Legacy code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Code documentation:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="skrt_modules.html">skrt</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="skrt.html">skrt package</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="skrt.html#subpackages">Subpackages</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="skrt.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="skrt.application.html">skrt.application module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.core.html">skrt.core module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.dicom_writer.html">skrt.dicom_writer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.dose.html">skrt.dose module</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">skrt.image module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.multi.html">skrt.multi module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.patient.html">skrt.patient module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.registration.html">skrt.registration module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.segmentation.html">skrt.segmentation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.simulation.html">skrt.simulation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="skrt.structures.html">skrt.structures module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="skrt.html#module-skrt">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="voxtox_modules.html">voxtox</a></li>
<li class="toctree-l1"><a class="reference internal" href="import_analysis_modules.html">import_analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Scikit-rt</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="skrt_modules.html">skrt</a></li>
          <li class="breadcrumb-item"><a href="skrt.html">skrt package</a></li>
      <li class="breadcrumb-item active">skrt.image module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/skrt.image.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-skrt.image">
<span id="skrt-image-module"></span><h1>skrt.image module<a class="headerlink" href="#module-skrt.image" title="Permalink to this heading"></a></h1>
<p>Classes for loading and comparing medical images.</p>
<dl class="py class">
<dt class="sig sig-object py" id="skrt.image.Image">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">Image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nifti_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_timestamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-200,</span> <span class="pre">300)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.299,</span> <span class="pre">0.587,</span> <span class="pre">0.114)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_intercept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="skrt.core.html#skrt.core.Archive" title="skrt.core.Archive"><code class="xref py py-class docutils literal notranslate"><span class="pre">Archive</span></code></a></p>
<p>Class representing a medical image.</p>
<p>Attributes of an Image object should usually be accessed via
their getter methods, rather than directly, to ensure that
attribute values have been loaded.</p>
<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nifti_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downsample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auto_timestamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(-200,</span> <span class="pre">300)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.299,</span> <span class="pre">0.587,</span> <span class="pre">0.114)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_intercept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialise from a medical image source.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>path<span class="classifier">str/array/Nifti1Image, default = “”</span></dt><dd><p>Source of image data. Can be either:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>A string, optionally with wildcards,
containing the path to one or multiple dicom files,
the path to a directory containg dicom files,
or the path to a single nifti file;</p></li>
<li><p>A list of paths, optionally with wildcards, to dicom files;</p></li>
<li><p>A string, optionally containing wildcards, containing
the path to a single numpy file containing a 2D or 3D array;</p></li>
<li><p>A 2D or 3D numpy array;</p></li>
<li><p>A nibabel.nifti1.Nifti1Image object;</p></li>
<li><p>An existing Image object to be cloned; in this case, all 
other input args except &lt;title&gt; will be ignored, as these 
will be taken from the existing Image.</p></li>
</ol>
</div></blockquote>
<p>Notes:</p>
<ol class="arabic simple">
<li><p>If path points to a single file, all files in the same
directory as this file are considered also.</p></li>
</ol>
<p>2. When path resolves to multiple dicom files, only files
that match the values of the first file for the dicom
attributes: “StudyInstanceUID”, “SeriesNumber”, “Modality”,
“ImageOrientationPatient”.  When path points to a single file
in a directory with others, this file is taken as the first
file.  Otherwise, files are sorted according to natural sort
order (so “2.dcm” before “11.dcm”).  To load images from files
in a single directory (or in a directory tree) that may have
different values for these, it could be better to use the
skrt.patient.Patient class:</p>
<p>from skrt import Patient
p = Patient(“path/to/directory”, unsorted_dicom=True)</p>
<p>For more details, see documentation of Patient class.</p>
</dd>
<dt>load<span class="classifier">bool, default=True</span></dt><dd><p>If True, the image data will be immediately loaded. Otherwise, it
can be loaded later with the load() method.</p>
</dd>
<dt>title<span class="classifier">str, default=None</span></dt><dd><p>Title to use when plotting the image. If None and &lt;source&gt; is a
path, a title will be automatically generated from the filename.</p>
</dd>
<dt>affine<span class="classifier">4x4 array, default=None</span></dt><dd><p>Array containing the affine matrix to use if &lt;source&gt; is a numpy
array or path to a numpy file. If not None, this takes precendence
over &lt;voxel_size&gt; and &lt;origin&gt;.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple, default=(1, 1, 1)</span></dt><dd><p>Voxel sizes in mm in order (x, y, z) to use if &lt;source&gt; is a numpy
array or path to a numpy file and &lt;affine&gt; is not provided.</p>
</dd>
<dt>origin<span class="classifier">tuple, default=(0, 0, 0)</span></dt><dd><p>Origin position in mm in order (x, y, z) to use if &lt;source&gt; is a
numpy array or path to a numpy file and &lt;affine&gt; is not provided.</p>
</dd>
<dt>nifti_array<span class="classifier">bool, default=False</span></dt><dd><p>If True and &lt;source&gt; is a numpy array or numpy file, the array
will be treated as a nifti-style array, i.e. (x, y, z) in
(row, column, slice), as opposed to dicom style.</p>
</dd>
<dt>downsample<span class="classifier">int/list, default=None</span></dt><dd><p>Amount by which to downsample the image. Can be a single value for
all axes, or a list containing downsampling amounts in order
(x, y, z).</p>
</dd>
<dt>dtype<span class="classifier">type, default=None</span></dt><dd><p>Type to which loaded data should be cast.</p>
</dd>
<dt>auto_timestamp<span class="classifier">bool default=False</span></dt><dd><p>If true and no valid timestamp is found within the path string,
timestamp generated from current date and time.</p>
</dd>
<dt>default_intensity<span class="classifier">tuple,None default=(-200, 300)</span></dt><dd><p>Default intensity range for image display.  This can
be specified as a two-element tuple, giving minimum and maximum,
or if set to None then intensity range used is from the
minimum of zero and the image minimum, to the image maximum.
If WindowCenter and WindowWidth are defined in a
DICOM source file, these values will be used instead to
define the default intensity range.</p>
</dd>
<dt>log_level: str/int/None, default=None</dt><dd><p>Severity level for event logging.  If the value is None,
log_level is set to the value of skrt.core.Defaults().log_level.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.add_dose">
<span class="sig-name descname"><span class="pre">add_dose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.add_dose" title="Permalink to this definition"></a></dt>
<dd><p>Add a Dose object to be associated with this image. This does not
affect the image associated with the Dose object.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>dose<span class="classifier">skrt.dose.Dose</span></dt><dd><p>A Dose object to assign to this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.add_plan">
<span class="sig-name descname"><span class="pre">add_plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plan</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.add_plan" title="Permalink to this definition"></a></dt>
<dd><p>Add a Plan object to be associated with this image. This does not
affect the image associated with the Plan object.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>plan<span class="classifier">skrt.dose.Plan</span></dt><dd><p>A Plan object to assign to this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.add_sinogram_noise">
<span class="sig-name descname"><span class="pre">add_sinogram_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">185000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.add_sinogram_noise" title="Permalink to this definition"></a></dt>
<dd><p>Add Poisson fluctuations at level of sinogram.</p>
<p>For a kV CT scan mapped to the radiodensity scale of an MV CT scan
(self.map_hu(‘kv_to_mv’), this function adds intensity fluctuations
to reproduce better the fluctuations in an MV CT scan.</p>
<p>The procedure for adding fluctuations was originally devised and
implemented by M.Z. Wilson.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>phi0<span class="classifier">int/float, default=60000</span></dt><dd><p>Notional photon flux used in image creation.</p>
</dd>
<dt>eta<span class="classifier">int/float, default=185000</span></dt><dd><p>Notional constant of proportionality linking radiodensity
and line integrals measuring attenuation along photon paths.</p>
</dd>
<dt>verbose<span class="classifier">bool, default=False</span></dt><dd><p>Print information on progress in noise addition</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.add_structure_set">
<span class="sig-name descname"><span class="pre">add_structure_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.add_structure_set" title="Permalink to this definition"></a></dt>
<dd><p>Add a structure set to be associated with this image. This does
not affect the image associated with the structure set.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>structure_set<span class="classifier">skrt.structures.StructureSet</span></dt><dd><p>A StructureSet object to assign to this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.apply_banding">
<span class="sig-name descname"><span class="pre">apply_banding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.apply_banding" title="Permalink to this definition"></a></dt>
<dd><p>Apply banding to image data.</p>
<p><strong>Parameter:</strong></p>
<dl>
<dt>bands - dict, default=None</dt><dd><p>Dictionary of value bandings to be applied to image data.
Keys specify band limits, and values indicte the values
to be assigned.  For example:</p>
<ul class="simple">
<li><p>bands{-100: -1024, 100: 0, 1e10: 1024}</p></li>
</ul>
<p>will result in the following banding:</p>
<ul class="simple">
<li><p>value &lt;= -100 =&gt; -1024;</p></li>
<li><p>-100 &lt; value &lt;= 100 =&gt; 0;</p></li>
<li><p>100 &lt; value &lt;= 1e10 =&gt; 1024.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.apply_selective_banding">
<span class="sig-name descname"><span class="pre">apply_selective_banding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.apply_selective_banding" title="Permalink to this definition"></a></dt>
<dd><p>Apply banding to selected intensity ranges of image data.</p>
<p>This is one of two skrt.image.Image methods to perform banding:</p>
<ul class="simple">
<li><p>apply_banding():
assign all intensity values to bands;</p></li>
<li><p>apply_selective_banding():
assign only selected intensity values to bands.</p></li>
</ul>
<p>Both methods accept as input a dictionary specifying bands, but
the dictionary format for the two methods is different.</p>
<p><strong>Parameter:</strong></p>
<dl>
<dt>bands - dict, default=None</dt><dd><p>Dictionary of value bandings to be applied to image data.
Keys are floats specifying intensities to be assigned, and
values are two-element tuples indicating lower and upper
band limits.  If the first element is None, no lower limit
is applied; if the second element is None, no upper limit
is applied.  For example:</p>
<ul class="simple">
<li><p>bands{-1024: (None, -100), 1024: (100, None}</p></li>
</ul>
<p>will result in the following banding:</p>
<ul class="simple">
<li><p>value &lt;= -100 =&gt; -1024;</p></li>
<li><p>-100 &lt; value &lt;= 100 =&gt; original values retained;</p></li>
<li><p>100 &lt; value =&gt; 1024.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.assign_intensity_to_rois">
<span class="sig-name descname"><span class="pre">assign_intensity_to_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rois</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.assign_intensity_to_rois" title="Permalink to this definition"></a></dt>
<dd><p>Assign intensity value to image regions corresponding to ROIs.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>rois<span class="classifier">list of skrt.structures.ROI objects, default=None</span></dt><dd><p>ROIs for which voxels are to be assigned an intensity value.</p>
</dd>
<dt>intensity<span class="classifier">int/float, default=0</span></dt><dd><p>Intensity value to be assigned to ROI voxels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.assign_structure_set">
<span class="sig-name descname"><span class="pre">assign_structure_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure_set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.assign_structure_set" title="Permalink to this definition"></a></dt>
<dd><p>Assign a structure set to this image.</p>
<p>This does not affect the image associated with the structure set.
Any previously assigned structure sets are cleared.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>structure_set<span class="classifier">skrt.structures.StructureSet</span></dt><dd><p>A StructureSet object to assign to this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.astype">
<span class="sig-name descname"><span class="pre">astype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">itype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.astype" title="Permalink to this definition"></a></dt>
<dd><p>Return image object with requested type of representation.</p>
<p>Image objects loaded from a DICOM source and Image objects
loaded from a NIfTI source have different representations
for two reasons:</p>
<ul class="simple">
<li><p>indices for an image slice have the order
[row][column] in pydicom vs [column][row] in nibabel;</p></li>
<li><p>axis definitions follow radiology convention
in pydicom vs neurology convention in nibabel; for discussion
of the conventions, see:
<a class="reference external" href="https://nipy.org/nibabel/neuro_radio_conventions.html">https://nipy.org/nibabel/neuro_radio_conventions.html</a></p></li>
</ul>
<p>This function returns the requested representation,
independently of the original source.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>itype<span class="classifier">str</span></dt><dd><p>Identifier of the representation type required.  Allowed
values are ‘dcm’ and ‘dicom’ for a pydicom/DICOM
representation; ‘nii’ and ‘nifti’ for a nibabel/NIfTI
representation.  For any other value, None is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.clear_doses">
<span class="sig-name descname"><span class="pre">clear_doses</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.clear_doses" title="Permalink to this definition"></a></dt>
<dd><p>Clear all dose maps associated with this image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.clear_plans">
<span class="sig-name descname"><span class="pre">clear_plans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.clear_plans" title="Permalink to this definition"></a></dt>
<dd><p>Clear all plan maps associated with this image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.clear_structure_sets">
<span class="sig-name descname"><span class="pre">clear_structure_sets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.clear_structure_sets" title="Permalink to this definition"></a></dt>
<dd><p>Clear all structure sets associated with this image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.clone_with_structure_set">
<span class="sig-name descname"><span class="pre">clone_with_structure_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_structure_set_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">structure_set_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.clone_with_structure_set" title="Permalink to this definition"></a></dt>
<dd><p>Clone current image, and associate to clone a filtered structure set.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>structure_set<span class="classifier">skrt.structures.StructureSet, default=None</span></dt><dd><p>Structure set to be filtered and associated to image clone.
Disregarded if a null value.</p>
</dd>
<dt>roi_names<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary for renaming and filtering ROIs, where the
keys are names for ROIs to be kept, and values are lists of
alternative names with which these ROIs may have been labelled.
The alternative names can contain wildcards with the ‘*’ symbol.
If a value of None is given, all ROIs in the structure set
are kept, with no renaming.</p>
</dd>
<dt>image_structure_set_index, int, default=-1</dt><dd><p>Integer specifying index in current image’s list of structure
sets of structure set to be associated with clone.  This
parameter is considered only if structure_set has a null value.</p>
</dd>
<dt>structure_set_name, str, default=None</dt><dd><p>Name to be assigned to structure set.  If None, existing name
is kept.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.copy_dicom">
<span class="sig-name descname"><span class="pre">copy_dicom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image_dicom'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.copy_dicom" title="Permalink to this definition"></a></dt>
<dd><p>Copy source dicom files.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>outdir<span class="classifier">pathlib.Path/str, default=”image_dicom”</span></dt><dd><p>Path to directory to which source files are to be copied.</p>
</dd>
<dt>overwrite<span class="classifier">bool, default=True</span></dt><dd><p>If True, delete and recreate &lt;outdir&gt; before copying
files.  If False and &lt;outdir&gt; exists already, a file
is copied only if this doesn’t mean overwriting an
existing file.</p>
</dd>
<dt>sort<span class="classifier">bool, default=True</span></dt><dd><p>If True, copied dicom files will be named by instance number
if all files have a different instance number, or else
will be numbered sequentially from 1, in order of increasing
z-coordinate.  If False, files are copied to the output directory
with their names unaltered.</p>
</dd>
<dt>args<span class="classifier">list</span></dt><dd><p>Arguments to be ignored.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Keyword arguments to be ignored.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.crop">
<span class="sig-name descname"><span class="pre">crop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.crop" title="Permalink to this definition"></a></dt>
<dd><p>Crop the image to a given x, y, z range in mm. If any are None, the 
image will not be cropped in that direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.crop_about_point">
<span class="sig-name descname"><span class="pre">crop_about_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.crop_about_point" title="Permalink to this definition"></a></dt>
<dd><p>Crop the image to a given x, y, z range in mm about a point.</p>
<p>If any range is None, the image will not be cropped in that direction.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>point<span class="classifier">tuple, default=None</span></dt><dd><p>(x, y, z) coordinates about which cropping is to be performed.
If None, the point (0, 0, 0) is used, and the result will be
the same as when calling the Image.crop() method.</p>
</dd>
<dt>xlim<span class="classifier">tuple, default=None</span></dt><dd><p>Lower and upper bounds relative to reference point of cropping
along x-axis.  If None, cropping is not performed along this axis.</p>
</dd>
<dt>ylim<span class="classifier">tuple, default=None</span></dt><dd><p>Lower and upper bounds relative to reference point of cropping
along y-axis.  If None, cropping is not performed along this axis.</p>
</dd>
<dt>zlim<span class="classifier">tuple, default=None</span></dt><dd><p>Lower and upper bounds relative to reference point of cropping
along z-axis.  If None, cropping is not performed along this axis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.crop_by_amounts">
<span class="sig-name descname"><span class="pre">crop_by_amounts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.crop_by_amounts" title="Permalink to this definition"></a></dt>
<dd><p>Crop image by the amounts dx, dy, dz in mm.</p>
<p>This method calls the function skrt.image.crop_by_amounts(), with
self passed as object for cropping.</p>
<p>The amount of cropping along each direction should be one of:
- float : the image is cropped by this amount on both sides;
- two-element tuple: the image is cropped on the sides of lower</p>
<blockquote>
<div><p>and higher values by the amounts specified;</p>
</div></blockquote>
<ul class="simple">
<li><p>None : no cropping is performed.</p></li>
</ul>
<p>For more details, see documentation of skrt.image.crop_by_amounts().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.crop_to_image">
<span class="sig-name descname"><span class="pre">crop_to_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.crop_to_image" title="Permalink to this definition"></a></dt>
<dd><p>Crop to extents of another image, optionally after image alignment.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image to whose extents to perform cropping.</p>
</dd>
<dt>alignment<span class="classifier">tuple/dict/str, default=None</span></dt><dd><p>Strategy to be used for image alignment prior to cropping.
For further details, see documentation of
skrt.image.get_alignment_translation().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.crop_to_roi">
<span class="sig-name descname"><span class="pre">crop_to_roi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crop_margins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crop_about_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.crop_to_roi" title="Permalink to this definition"></a></dt>
<dd><p>Crop image to region defined by an ROI or StructureSet, plus margins.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>rois<span class="classifier">skrt.structures.ROI/skirt.structures.StructureSet</span></dt><dd><p>ROI or StructureSet to which image will be cropped.</p>
</dd>
<dt>crop_margins<span class="classifier">float/tuple, default=None</span></dt><dd><p>Float or three-element tuple specifying the margins, in mm,
to be added to extents or centre point of ROI or StructureSet.  If
a float, minus and plus the value specified are added to lower
and upper extents respectively along each axis.  If a
three-element tuple, elements are taken to specify margins in
the order (x, y, z).  Elements can be either floats (minus and
plus the value added respectively to lower and upper extents)
or two-element tuples (elements 0 and 1 added respectively
to lower and upper extents).</p>
</dd>
<dt>crop_about_centre<span class="classifier">bool, default=False</span></dt><dd><p>If True, image is cropped to the centre point of ROI or
StructureSet plus margins.  If False, image is cropped to 
the extents of ROI or StructureSet plus margins.</p>
</dd>
<dt>method<span class="classifier">str, default=None</span></dt><dd><p>Method to use for calculating extent of &lt;roi&gt; region. Can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>“contour”: get extent from min/max positions of contour(s).</p></li>
<li><p>“mask”: get extent from min/max positions of voxels in the 
binary mask.</p></li>
<li><p>None: use the method set in self.default_geom_method.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.downsample">
<span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">downsampling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.downsample" title="Permalink to this definition"></a></dt>
<dd><p>Apply downsampling to the image array. Can be either a single
value (to downsampling equally in all directions) or a list of 3
values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_affine">
<span class="sig-name descname"><span class="pre">get_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_affine" title="Permalink to this definition"></a></dt>
<dd><p>Return affine matrix.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>standardise<span class="classifier">bool, default=False</span></dt><dd><p>If False, the affine matrix will be returned in the orientation in 
which it was loaded; otherwise, it will be returned in standard
dicom-style orientation such that [column, row, slice] corresponds
to the [x, y, z] axes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_alignment_translation">
<span class="sig-name descname"><span class="pre">get_alignment_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_alignment_translation" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning &lt;self&gt; to &lt;other&gt;.</p>
<p>This method calls the function of the same name,
with &lt;self&gt; and &lt;other&gt; as &lt;im1&gt; and &lt;im2&gt; respectively.</p>
<p>For explanation of parameters, see documentation of
skrt.image.get_alignment_translation().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_axes">
<span class="sig-name descname"><span class="pre">get_axes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">col_first</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_axes" title="Permalink to this definition"></a></dt>
<dd><p>Return list of axis numbers in order [column, row, slice] if
col_first is True, otherwise in order [row, column, slice]. The axis
numbers 0, 1, and 2 correspond to x, y, and z, respectively.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>col_first<span class="classifier">bool, default=True</span></dt><dd><p>If True, return axis numbers in order [column, row, slice] instead
of [row, column, slice].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_centre">
<span class="sig-name descname"><span class="pre">get_centre</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_centre" title="Permalink to this definition"></a></dt>
<dd><p>Get position in mm of the centre of the image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_centroid_idx">
<span class="sig-name descname"><span class="pre">get_centroid_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_centroid_idx" title="Permalink to this definition"></a></dt>
<dd><p>Get array index of slice containing centroid of above-threshold voxels.</p>
<p>The centroid coordinate along a given axis is calculated as the
unweighted mean of the coordinates of voxels with an intensity at
least a given fraction of the maximum.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str, default=”x-y”</span></dt><dd><p>Orientation; can be “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”.</p>
</dd>
<dt>fraction<span class="classifier">float, default=1</span></dt><dd><p>Minimum fraction of the maximum intensity that a voxel must record
to be considered in the centroid calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_centroid_pos">
<span class="sig-name descname"><span class="pre">get_centroid_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_centroid_pos" title="Permalink to this definition"></a></dt>
<dd><p>Get position of slice containing centroid of above-threshold voxels.</p>
<p>The centroid coordinate along a given axis is calculated as the
unweighted mean of the coordinates of voxels with an intensity at
least a given fraction of the maximum.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str, default=”x-y”</span></dt><dd><p>Orientation; can be “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”.</p>
</dd>
<dt>fraction<span class="classifier">float, default=1</span></dt><dd><p>Minimum fraction of the maximum intensity that a voxel must record
to be considered in the centroid calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_centroid_slice">
<span class="sig-name descname"><span class="pre">get_centroid_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_centroid_slice" title="Permalink to this definition"></a></dt>
<dd><p>Get number of slice containing centroid of above-threshold voxels.</p>
<p>The centroid coordinate along a given axis is calculated as the
unweighted mean of the coordinates of voxels with an intensity at
least a given fraction of the maximum.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str, default=”x-y”</span></dt><dd><p>Orientation; can be “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”.</p>
</dd>
<dt>fraction<span class="classifier">float, default=1</span></dt><dd><p>Minimum fraction of the maximum intensity that a voxel must record
to be considered in the centroid calculation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_comparison">
<span class="sig-name descname"><span class="pre">get_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_as_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nice_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimal_places</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_comparison" title="Permalink to this definition"></a></dt>
<dd><p>Return a pandas DataFrame comparing this image with another.</p>
<p>If this image doesn’t have the same shape and geometry as
the other image, comparison metrics are evaluated for a clone
of this image, resized to match the other.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>other<span class="classifier">skrt.image.Image</span></dt><dd><p>Other image, with which to compare this image.</p>
</dd>
<dt>metrics<span class="classifier">list, default=None</span></dt><dd><p>List of metrics to evaluate.  Available metrics:</p>
<p>Calculated in Image.get_mutual_information():</p>
<blockquote>
<div><ul class="simple">
<li><p>“mutual_information”;</p></li>
<li><p>“normalised_mutual_information”;</p></li>
<li><p>“information_quality_ratio”;</p></li>
<li><p>“rajski_distance”.</p></li>
</ul>
</div></blockquote>
<p>Calculated in Image.get_quality():</p>
<blockquote>
<div><ul class="simple">
<li><p>“relative_structural_content”;</p></li>
<li><p>“fidelity”;</p></li>
<li><p>“correlation_quality”.</p></li>
</ul>
</div></blockquote>
<p>If None, defaults to [“mutual_information”]</p>
</dd>
<dt>name<span class="classifier">str, default=None</span></dt><dd><p>Name identifying comparison.  If null, the name is
constructed from the titles of the two images compared,
as “title1_vs_title2”.</p>
</dd>
<dt>name_as_index<span class="classifier">bool, default=True</span></dt><dd><p>If True, the index column of the pandas DataFrame will 
contain the name of this comparison; otherwise, the name will
appear in a column labelled “images”.</p>
</dd>
<dt>nice_columns<span class="classifier">bool, default=False</span></dt><dd><p>If False, column labels will be the same as the input metric names;
if True, the names will be capitalized and underscores will be 
replaced with spaces.</p>
</dd>
<dt>decimal_places<span class="classifier">int, default=None</span></dt><dd><p>Number of decimal places to keep for each metric. If None, full
precision will be used.</p>
</dd>
<dt>base<span class="classifier">int/None, default=2</span></dt><dd><p>Base to use when taking logarithms, in calculations of
mutual information and variants.  If None, use base e.</p>
</dd>
<dt>bins<span class="classifier">int/list, default=50</span></dt><dd><p>Numbers of bins to use when histogramming grey-level joint
probabilities for self and other, in calculations of
mutual information and variants.  This is passed as
the bins parameter of numpy.histogram2d:
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html">https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html</a></p>
</dd>
<dt>xyrange<span class="classifier">list, default=None</span></dt><dd><p>Upper and lower of each axis when histogramming grey-level
joint probabilities for self and image, in calculations of
mutual informatio and variants.  This is passed as
the range parameter of numpy.histogram2d:
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html">https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_coordinate_arrays">
<span class="sig-name descname"><span class="pre">get_coordinate_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_coordinate_arrays" title="Permalink to this definition"></a></dt>
<dd><p>Obtain (x, y, z) arrays of coordinates of voxel centres.</p>
<p>Arrays are useful for image resizing.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image_size<span class="classifier">tuple</span></dt><dd><p>Image size in voxels, in order (x,y,z).</p>
</dd>
<dt>origin<span class="classifier">tuple</span></dt><dd><p>Origin position in mm in order (x, y, z).</p>
</dd>
<dt>voxel_size<span class="classifier">tuple</span></dt><dd><p>Voxel sizes in mm in order (x, y, z).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_coords">
<span class="sig-name descname"><span class="pre">get_coords</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_coords" title="Permalink to this definition"></a></dt>
<dd><p>Get grids of x, y, and z coordinates for each voxel in the image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_correlation_quality">
<span class="sig-name descname"><span class="pre">get_correlation_quality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_correlation_quality" title="Permalink to this definition"></a></dt>
<dd><p>Calculate quality of correlation between this image and another.</p>
<p>Uses method get_quality().</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with respect to which correlation quality is to be calculated.
to be evaluated</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_data">
<span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_data" title="Permalink to this definition"></a></dt>
<dd><p>Return 3D image array.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>standardise<span class="classifier">bool, default=False</span></dt><dd><p>If False, the data array will be returned in the orientation in 
which it was loaded; otherwise, it will be returned in standard
dicom-style orientation such that [column, row, slice] corresponds
to the [x, y, z] axes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_dicom_array_and_affine">
<span class="sig-name descname"><span class="pre">get_dicom_array_and_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_dicom_array_and_affine" title="Permalink to this definition"></a></dt>
<dd><p>Get image array and affine matrix in dicom configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_dicom_dataset">
<span class="sig-name descname"><span class="pre">get_dicom_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_dicom_dataset" title="Permalink to this definition"></a></dt>
<dd><p>Return pydicom.dataset.FileDataset object associated with this Image
if it was loaded from dicom; otherwise, return None.</p>
<p>If any of &lt;sl&gt;, &lt;idx&gt; or &lt;pos&gt; are provided, the dataset corresponding
to that specific slice will be returned; otherwise, the last loaded
dataset will be returned.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number; used if not None.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Slice array index; used if not None and &lt;sl&gt; is None.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Slice position in mm; used if not None and &lt;sl&gt; and &lt;idx&gt; are both
None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_dicom_filepath">
<span class="sig-name descname"><span class="pre">get_dicom_filepath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_dicom_filepath" title="Permalink to this definition"></a></dt>
<dd><p>Return path to the dicom dataset corresponding to a specific 
slice.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number; used if not None.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Slice array index; used if not None and &lt;sl&gt; is None.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Slice position in mm; used if not None and &lt;sl&gt; and &lt;idx&gt; are both
None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_doses">
<span class="sig-name descname"><span class="pre">get_doses</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_doses" title="Permalink to this definition"></a></dt>
<dd><p>Return list of Dose objects associated with this Image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_extents">
<span class="sig-name descname"><span class="pre">get_extents</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_extents" title="Permalink to this definition"></a></dt>
<dd><p>Get minimum and maximum extent of the image in mm along all three axes,
returned in order [x, y, z].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_fidelity">
<span class="sig-name descname"><span class="pre">get_fidelity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_fidelity" title="Permalink to this definition"></a></dt>
<dd><p>Calculate fidelity with which this image matches another.</p>
<p>Uses method get_quality().</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with respect to which fidelity is to be calculated.
to be evaluated</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_bbox">
<span class="sig-name descname"><span class="pre">get_foreground_bbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_bbox" title="Permalink to this definition"></a></dt>
<dd><p>Obtain bounding box of image foreground.</p>
<p>The bounding box is returned as
[(xmin, xmax), (ymin, ymax), (zmin, zmax)], with values in mm.</p>
<p>Method parameters are passed to skrt.image.Image.get_foreground_mask()
to obtain a mask defining the image foreground.  For parameter
explanations, see skrt.image.Image.get_foreground_mask() documentation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_bbox_centre_and_widths">
<span class="sig-name descname"><span class="pre">get_foreground_bbox_centre_and_widths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_bbox_centre_and_widths" title="Permalink to this definition"></a></dt>
<dd><p>Get centre and widths in mm along all three axes of a
bounding box enclosing the image foreground.  Centre
and widths are returned as a tuple ([x, y, z], [dx, dy, dz]).</p>
<p>Method parameters are passed to skrt.image.Image.get_foreground_mask()
to obtain a mask defining the image foreground.  For parameter
explanations, see skrt.image.Image.get_foreground_mask() documentation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_box_mask">
<span class="sig-name descname"><span class="pre">get_foreground_box_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_box_mask" title="Permalink to this definition"></a></dt>
<dd><p>Slice by slice, create rectangular mask enclosing foreground mask.</p>
<dl class="simple">
<dt>dx<span class="classifier">int, default=0</span></dt><dd><p>Margin along columns to be added on each side of mask bounding box.</p>
</dd>
<dt>dy<span class="classifier">int, default=0</span></dt><dd><p>Margin along rows to be added on each side of mask bounding box.</p>
</dd>
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels in a slice are assigned to
regions for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_comparison">
<span class="sig-name descname"><span class="pre">get_foreground_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_comparison" title="Permalink to this definition"></a></dt>
<dd><p>Return a pandas DataFrame comparing the foregrounds of
this image and another.</p>
<p>ROIs obtaining the image foregrounds are obtained, then
these are compared using skrt.structures.ROI.get_comparison().</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>other: skrt.image.Image</dt><dd><p>Image with which this image is to be compared.</p>
</dd>
<dt>name: str, default=None</dt><dd><p>Name to be assigned to the ROI representing the foreground
of this image, and by default used as row index in DataFrame.
If null, the name used is the image title, or if this is null
then f”{skrt.core.Defaults().foreground_name}_1” is used.</p>
</dd>
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels in a slice are assigned to
regions for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, create mask from the convex hulls of the
slice foreground masks initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If True, fill holes in the slice foreground masks initially
obtained.</p>
</dd>
<dt>dxy<span class="classifier">int, default=0</span></dt><dd><p>Margin, in pixel units, to be added to each slice foreground mask.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple, default=None</span></dt><dd><p>Voxel size (dx, dy, dz) in mm to be used for foreground
masks in comparisons.  If None, the mask voxel size of
&lt;other&gt; is used if not None; otherwise the default voxel
size for dummy images, namely (1, 1, 1), is used.  If an
element of the tuple specifying voxel size is None, the
value for the corresponding element of the mask voxel size
of &lt;other&gt; is used.</p>
</dd>
<dt>kwargs: dict</dt><dd><p>Keyword arguments, in addition to voxel_size, passed to
skrt.structures.ROI.get_comparison().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_mask">
<span class="sig-name descname"><span class="pre">get_foreground_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_mask" title="Permalink to this definition"></a></dt>
<dd><p>Create foreground mask.</p>
<p>Slice by slice, the foreground is taken to correspond to the
largest region of contiguous pixels above a threshold value.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels in a slice are assigned to
regions for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, create mask from the convex hulls of the
slice foreground masks initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If True, fill holes in the slice foreground masks initially
obtained.</p>
</dd>
<dt>dxy<span class="classifier">int, default=0</span></dt><dd><p>Margin, in pixel units, to be added to each slice foreground mask.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_foreground_roi">
<span class="sig-name descname"><span class="pre">get_foreground_roi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_foreground_roi" title="Permalink to this definition"></a></dt>
<dd><p>Create ROI represening image foreground.</p>
<p>Slice by slice, the foreground is taken to correspond to the
largest region of contiguous pixels above a threshold value.
A binary mask representing the foreground is created, and
is used as source for creating an ROI.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels in a slice are assigned to
regions for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, create mask from the convex hulls of the
slice foreground masks initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If True, fill holes in the slice foreground masks initially
obtained.</p>
</dd>
<dt>dxy<span class="classifier">int, default=0</span></dt><dd><p>Margin, in pixel units, to be added to each slice foreground mask.</p>
</dd>
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs</dt><dd><p>Keyword arguments passed to ROI constructor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_idx">
<span class="sig-name descname"><span class="pre">get_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_idx" title="Permalink to this definition"></a></dt>
<dd><p>Get an array index from either a slice number, index, or
position. If &lt;sl&gt;, &lt;idx&gt;, and &lt;pos&gt; are all None, the index of the 
central slice of the image in the orienation specified in &lt;view&gt; will 
be returned.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str</span></dt><dd><p>Orientation in which to compute the index. 
Can be “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”.</p>
</dd>
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number. If given, this number will be converted to an index 
and returned.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Slice array index. If given and &lt;sl&gt; is None, this index will be 
returned.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Slice position in mm. If given and &lt;sl&gt; and &lt;idx&gt; are both None,
this position will be converted to an index and returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_intensity_mask">
<span class="sig-name descname"><span class="pre">get_intensity_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_intensity_mask" title="Permalink to this definition"></a></dt>
<dd><p>Create intensity mask.</p>
<p>Slice by slice, the mask corresponds to the largest region of
contiguous pixels with intensity values inside a given interval.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>vmin<span class="classifier">int/float, default=None</span></dt><dd><p>Minimum intensity value for pixel to be included in mask.
If None, no constraint on minimum intensity is applied.</p>
</dd>
<dt>vmax<span class="classifier">int/float, default=None</span></dt><dd><p>Maximum intensity value for pixel to be included in mask.
If None, no constraint on maximum intensity is applied.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, create mask from the convex hulls of the
slice foreground masks initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If True, fill holes in the slice foreground masks initially
obtained.</p>
</dd>
<dt>dxy<span class="classifier">int, default=0</span></dt><dd><p>Margin, in pixel units, to be added to each slice foreground mask.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_length">
<span class="sig-name descname"><span class="pre">get_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'z'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_length" title="Permalink to this definition"></a></dt>
<dd><p>Get total length of image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_machine">
<span class="sig-name descname"><span class="pre">get_machine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'0210167':</span> <span class="pre">'LA3',</span> <span class="pre">'0210292':</span> <span class="pre">'LA4'}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_machine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_masked_image">
<span class="sig-name descname"><span class="pre">get_masked_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_masked_image" title="Permalink to this definition"></a></dt>
<dd><p>Return image after application of mask.</p>
<dl class="simple">
<dt>mask<span class="classifier">Image/list/ROI/str/StructureSet, default=None</span></dt><dd><p>Image object representing a mask or a source from which
an Image object can be initialised.  In addition to the
sources accepted by the Image constructor, the source
may be an ROI, a list of ROIs or a StructureSet.  In the
latter cases, the mask image is derived from the ROI mask(s).</p>
</dd>
<dt>mask_threshold<span class="classifier">float, default=0.5</span></dt><dd><p>Threshold for mask data.  Values above and below this value are
set to True and False respectively.  Taken into account only
if the mask image has non-boolean data.</p>
</dd>
<dt>invert_mask<span class="classifier">bool, default=False</span></dt><dd><p>If True, the mask is inverted before being applied.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_max">
<span class="sig-name descname"><span class="pre">get_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_max" title="Permalink to this definition"></a></dt>
<dd><p>Get maximum greyscale value of data array.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_min">
<span class="sig-name descname"><span class="pre">get_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_min" title="Permalink to this definition"></a></dt>
<dd><p>Get minimum greyscale value of data array.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_mpl_kwargs">
<span class="sig-name descname"><span class="pre">get_mpl_kwargs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mpl_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_in_mm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_mpl_kwargs" title="Permalink to this definition"></a></dt>
<dd><p>Get a dict of kwargs for plotting this image in matplotlib. This
will create a default dict, which is updated to contain any kwargs
contained in &lt;mpl_kwargs&gt;.</p>
<dl class="simple">
<dt>The default parameters are:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“aspect”:</dt><dd><p>Aspect ratio determined from image geometry.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“extent”: </dt><dd><p>Plot extent determined from image geometry.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“cmap”:</dt><dd><p>Colormap, self._default_cmap by default.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“vmin”/”vmax”</dt><dd><p>Greyscale range to use; taken from self._default_vmin and
self._default_vmax by default.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>For information on matplotlib colour maps, see:</dt><dd><p><a class="reference external" href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">https://matplotlib.org/stable/gallery/color/colormap_reference.html</a></p>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str</span></dt><dd><p>Orientation; (any of “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”);
needed to compute correct aspect ratio and plot extent.</p>
</dd>
<dt>mpl_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dict of kwargs with which to overwrite default kwargs.</p>
</dd>
<dt>scale_in_mm<span class="classifier">bool, default=True</span></dt><dd><p>If True, indicates that image will be plotted with axis scales in 
mm; needed to compute correct aspect ratio and plot extent.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_mutual_information">
<span class="sig-name descname"><span class="pre">get_mutual_information</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xyrange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mutual_information'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_mutual_information" title="Permalink to this definition"></a></dt>
<dd><p>For this and another image, calculate mutual information or a variant.</p>
<p>The two images considered must have the same shape.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with respect to which mutual information is calculated.</p>
</dd>
<dt>base<span class="classifier">int/None, default=2</span></dt><dd><p>Base to use when taking logarithms.  If None, use base e.</p>
</dd>
<dt>bins<span class="classifier">int/list, default=50</span></dt><dd><p>Numbers of bins to use when histogramming grey-level joint
probabilities for self and image.  This is passed as
the bins parameter of numpy.histogram2d:
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html">https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html</a></p>
</dd>
<dt>xyrange<span class="classifier">list, default=None</span></dt><dd><p>Upper and lower of each axis when histogramming grey-level
joint probabilities for self and image.  This is passed as
the range parameter of numpy.histogram2d:
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html">https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html</a></p>
</dd>
<dt>variant<span class="classifier">str, default=None</span></dt><dd><p>Variant of mutual information to be returned.</p>
<ul class="simple">
<li><p>“mi”, “mutual_information”:
return mutual information, as introduced in:
<a class="reference external" href="https://doi.org/10.1002/j.1538-7305.1948.tb01338.x">https://doi.org/10.1002/j.1538-7305.1948.tb01338.x</a></p></li>
<li><p>“nmi”, “normalised_mutual_information”:
return normalised mutual information (range 1 to 2) as defined in:
<a class="reference external" href="https://doi.org/10.1117/12.310835">https://doi.org/10.1117/12.310835</a></p></li>
<li><p>“iqr”, “information_quality_ratio”:
return information quality ratio (range 0 to 1) as defined in:
<a class="reference external" href="https://doi.org/10.1016/j.chemolab.2016.11.012">https://doi.org/10.1016/j.chemolab.2016.11.012</a>
=&gt; information_quality_ratio = normalised_mutual_information - 1</p></li>
<li><p>“rajski”, “rajski_distance”:
return Rajski distance (range 1 to 0) as defined in:
<a class="reference external" href="https://doi.org/10.1016/S0019-9958(61)80055-7">https://doi.org/10.1016/S0019-9958(61)80055-7</a>
=&gt; rajski_distance = 2 - normalised_mutual_information</p></li>
<li><p>Any other value, return None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_n_voxels">
<span class="sig-name descname"><span class="pre">get_n_voxels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_n_voxels" title="Permalink to this definition"></a></dt>
<dd><p>Return number of voxels in order [x, y, z].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_nifti_array_and_affine">
<span class="sig-name descname"><span class="pre">get_nifti_array_and_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_nifti_array_and_affine" title="Permalink to this definition"></a></dt>
<dd><p>Get image array and affine matrix in canonical nifti
configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_orientation_codes">
<span class="sig-name descname"><span class="pre">get_orientation_codes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_orientation_codes" title="Permalink to this definition"></a></dt>
<dd><p>Get image orientation codes in order [row, column, slice] if 
image was loaded in dicom-style orientation, or [column, row, slice] 
if image was loaded in nifti-style orientation.</p>
<dl class="simple">
<dt>This returns a list of code strings. Possible codes:</dt><dd><p>“L” = Left (x axis)
“R” = Right (x axis)
“P” = Posterior (y axis)
“A” = Anterior (y axis)
“I” = Inferior (z axis)
“S” = Superior (z axis)</p>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>affine<span class="classifier">np.ndarray, default=None</span></dt><dd><p>Custom affine matrix to use when determining orientation codes.
If None, self.affine will be used.</p>
</dd>
<dt>source_type<span class="classifier">str, default=None</span></dt><dd><p>Assumed source type to use when determining orientation codes. If 
None, self.source_type will be used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_orientation_vector">
<span class="sig-name descname"><span class="pre">get_orientation_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_orientation_vector" title="Permalink to this definition"></a></dt>
<dd><p>Get image orientation as a row and column vector.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>affine<span class="classifier">np.ndarray, default=None</span></dt><dd><p>Custom affine matrix to use when determining orientation vector.
If None, self.affine will be used.</p>
</dd>
<dt>source_type<span class="classifier">str, default=None</span></dt><dd><p>Assumed source type to use when determining orientation vector. If 
None, self.source_type will be used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_orientation_view">
<span class="sig-name descname"><span class="pre">get_orientation_view</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_orientation_view" title="Permalink to this definition"></a></dt>
<dd><p>Determine view corresponding to the image’s orientation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_origin">
<span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_origin" title="Permalink to this definition"></a></dt>
<dd><p>Return origin position in mm in order [x, y, z].</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>standardise<span class="classifier">bool, default=False</span></dt><dd><p>If False, the origin will be returned for the image as loaded;
otherwise, it will be returned for the image in standard
dicom-style orientation, such that [column, row, slice] corresponds
to the [x, y, z] axes.</p>
</dd>
<dt>force_standardise<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised image will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_plans">
<span class="sig-name descname"><span class="pre">get_plans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_plans" title="Permalink to this definition"></a></dt>
<dd><p>Return list of Plan objects associated with this Image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_plot_aspect_ratio">
<span class="sig-name descname"><span class="pre">get_plot_aspect_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_colorbars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_plot_aspect_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Estimate the ideal width/height ratio for a plot of this image
in a given orientation.</p>
<dl class="simple">
<dt>view<span class="classifier">str</span></dt><dd><p>Orientation (‘x-y’, ‘x-z’, ‘y-x’, ‘y-z’, ‘z-x’, or ‘z-y’)</p>
</dd>
<dt>zoom<span class="classifier">float/list, default=None</span></dt><dd><p>Zoom factors; either a single value for all axes, or three values
in order (x, y, z).</p>
</dd>
<dt>n_colorbars<span class="classifier">int, default=0</span></dt><dd><p>Number of colorbars to make space for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_quality">
<span class="sig-name descname"><span class="pre">get_quality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_quality" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate quality of this image relative to another.</p>
<p>The metrics considered are:</p>
<ul class="simple">
<li><p>relative structural content;</p></li>
<li><p>fidelity;</p></li>
<li><p>correlation quality.</p></li>
</ul>
<p>These are defined in:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1364/JOSA.46.000740">https://doi.org/10.1364/JOSA.46.000740</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1080/713826248">https://doi.org/10.1080/713826248</a></p></li>
</ul>
<p>The three metrics should each have a value between 0 and 1,
and are related by:</p>
<p>correlation quality = 0.5 * (relative structural content + fidelity).</p>
<p>Quality scores are returned in a dictionary, with a key corresponding
to each metric: “relative_structural_content”, “fidelity”,
“correlation_quality”.  If a metric isn’t evaluated, the value
returned for it is None.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with respect to which quality metrics are to be calculated.</p>
</dd>
<dt>metrics: list, default=None</dt><dd><p>List of strings specifying quality metrics to be evaluated.
If None, all defined quality metrics are evaluated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_range">
<span class="sig-name descname"><span class="pre">get_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'z'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_range" title="Permalink to this definition"></a></dt>
<dd><p>Get range of the image in mm along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_relative_structural_content">
<span class="sig-name descname"><span class="pre">get_relative_structural_content</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_relative_structural_content" title="Permalink to this definition"></a></dt>
<dd><p>Calculate structural content of this image relative to another.</p>
<p>Uses method get_quality().</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with respect to which relative structural content is
to be evaluated</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_rois">
<span class="sig-name descname"><span class="pre">get_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_rois" title="Permalink to this definition"></a></dt>
<dd><p>Get all instances of ROIs with specified name in image structure sets.</p>
<p><strong>Parameter:</strong>
name : str</p>
<blockquote>
<div><p>Name for which ROI instances are to be returned.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_sinogram">
<span class="sig-name descname"><span class="pre">get_sinogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_sinogram" title="Permalink to this definition"></a></dt>
<dd><p>Retrieve image where each slice corresponds to a sinogram.</p>
<p>A slice sinogram is obtain through application of a Radon
transform to the original image slice.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=False</span></dt><dd><p>The first time that sinogram image is created, it is
stored as self.sinogram.  It is recreated only if force
is set to True.</p>
</dd>
<dt>verbose<span class="classifier">bool, default=False</span></dt><dd><p>Print information on progress in sinogram creation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_size">
<span class="sig-name descname"><span class="pre">get_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_size" title="Permalink to this definition"></a></dt>
<dd><p>Return image sizes in mm in order [x, y, z].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_slice">
<span class="sig-name descname"><span class="pre">get_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_slice" title="Permalink to this definition"></a></dt>
<dd><p>Get a slice of the data in the correct orientation for plotting. 
If &lt;sl&gt;, &lt;pos&gt;, and &lt;idx&gt; are all None, the central slice of the image
in the orientation specified in &lt;view&gt; will be returned.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>view<span class="classifier">str</span></dt><dd><p>Orientation; can be “x-y”, “x-z”, “y-x”, “y-z”, “z-x”, or “z-y”.</p>
</dd>
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number; used if not None.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Slice array index; used if not None and &lt;sl&gt; is None.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Slice position in mm; used if not None and &lt;sl&gt; and &lt;idx&gt; are both
None.</p>
</dd>
<dt>flatten<span class="classifier">bool, default=False</span></dt><dd><p>If True, the image will be summed across all slices in the 
orientation specified in &lt;view&gt;; &lt;sl&gt;/&lt;idx&gt;/&lt;pos&gt; will be ignored.</p>
</dd>
<dt>shift<span class="classifier">list, default=[None, None, None]</span></dt><dd><p>Translational shift in order [dx, dy, dz] to apply before returning
slice.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_slice_foreground">
<span class="sig-name descname"><span class="pre">get_slice_foreground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_slice_foreground" title="Permalink to this definition"></a></dt>
<dd><p>Create foreground mask for image slice.</p>
<p>The foreground is taken to correspond to the largest region
of contiguous pixels above a threshold value.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>idx<span class="classifier">int, default=0</span></dt><dd><p>Index of slice for which foreground mask is to be obtained.</p>
</dd>
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels are assigned to regions
for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, return the convex hull of the foreground mask
initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If False, fill holes in the foreground mask initially
obtained.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_standardised_affine">
<span class="sig-name descname"><span class="pre">get_standardised_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_standardised_affine" title="Permalink to this definition"></a></dt>
<dd><p>Return affine matrix in standard dicom orientation, where 
[column, row, slice] corresponds to the [x, y, z] axes.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised array will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_standardised_data">
<span class="sig-name descname"><span class="pre">get_standardised_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_standardised_data" title="Permalink to this definition"></a></dt>
<dd><p>Return array in standard dicom orientation, where 
[column, row, slice] corresponds to the [x, y, z] axes.
standardised image array.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised array will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_standardised_origin">
<span class="sig-name descname"><span class="pre">get_standardised_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_standardised_origin" title="Permalink to this definition"></a></dt>
<dd><p>Return origin for image in standard dicom orientation, where 
[column, row, slice] corresponds to the [x, y, z] axes.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised array will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_standardised_voxel_size">
<span class="sig-name descname"><span class="pre">get_standardised_voxel_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_standardised_voxel_size" title="Permalink to this definition"></a></dt>
<dd><p>Return voxel size for image in standard dicom orientation, where 
[column, row, slice] corresponds to the [x, y, z] axes.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised array will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_structure_sets">
<span class="sig-name descname"><span class="pre">get_structure_sets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_structure_sets" title="Permalink to this definition"></a></dt>
<dd><p>Return list of StructureSet objects associated with this Image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_translation_to_align">
<span class="sig-name descname"><span class="pre">get_translation_to_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_translation_to_align" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning &lt;self&gt; to &lt;other&gt;.</p>
<p>This method calls the function of the same name,
with &lt;self&gt; and &lt;other&gt; as &lt;im1&gt; and &lt;im2&gt; respectively.</p>
<p>For explanation of parameters, see documentation of
skrt.image.get_translation_to_align().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_translation_to_align_image_rois">
<span class="sig-name descname"><span class="pre">get_translation_to_align_image_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_name1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_name2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_fraction1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_fraction2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_translation_to_align_image_rois" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning ROI of &lt;self&gt; to ROI of &lt;other&gt;.</p>
<p>This method calls the function of the same name,
with &lt;self&gt; and &lt;other&gt; as &lt;im1&gt; and &lt;im2&gt; respectively.</p>
<p>For explanation of parameters, see documentation of
skrt.image.get_translation_to_align_image_rois().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_volume">
<span class="sig-name descname"><span class="pre">get_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mm'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_volume" title="Permalink to this definition"></a></dt>
<dd><p>Get image volume in specified units.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>units<span class="classifier">str, default=”mm”</span></dt><dd><dl class="simple">
<dt>Units of volume. Can be any of:</dt><dd><ul class="simple">
<li><p>“mm”: return volume in millimetres cubed.</p></li>
<li><p>“ml”: return volume in millilitres.</p></li>
<li><p>“voxels”: return volume in number of voxels.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_voxel_coords">
<span class="sig-name descname"><span class="pre">get_voxel_coords</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_voxel_coords" title="Permalink to this definition"></a></dt>
<dd><p>Get arrays of voxel coordinates in each direction.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.get_voxel_size">
<span class="sig-name descname"><span class="pre">get_voxel_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.get_voxel_size" title="Permalink to this definition"></a></dt>
<dd><p>Return voxel sizes in mm in order [x, y, z].</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>standardise<span class="classifier">bool, default=False</span></dt><dd><p>If False, the voxel size will be returned for the image as loaded;
otherwise, it will be returned for the image in standard
dicom-style orientation, such that [column, row, slice] corresponds
to the [x, y, z] axes.</p>
</dd>
<dt>force_standardise<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised image will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.has_same_data">
<span class="sig-name descname"><span class="pre">has_same_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.has_same_data" title="Permalink to this definition"></a></dt>
<dd><p>Check whether this Image has the same data as
another Image &lt;im&gt; (i.e. same array shape and same data values),
with tolerance &lt;max_diff&gt; on agreement of data values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.has_same_geometry">
<span class="sig-name descname"><span class="pre">has_same_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_diff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.has_same_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Check whether this Image has the same geometric properties as
another Image (i.e. same origins and voxel sizes within tolerance,
same shapes).</p>
<p><strong>Parameters:</strong>
im : skrt.image.Image</p>
<blockquote>
<div><p>Image with which to compare geometry.</p>
</div></blockquote>
<dl class="simple">
<dt>max_diff<span class="classifier">float, default=0.005</span></dt><dd><p>Maximum difference accepted between components of origins
and voxel sizes.</p>
</dd>
<dt>standardise<span class="classifier">bool, default=False</span></dt><dd><p>If False, geometry is compared for the images as loaded;
otherwise, geometry is compared for the images in standard
dicom-style orientation, such that [column, row, slice] corresponds
to the [x, y, z] axes.</p>
</dd>
<dt>force_standardise<span class="classifier">bool, default=True</span></dt><dd><p>If True, the standardised image will be recomputed from self.data 
even if it has previously been computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.idx_to_pos">
<span class="sig-name descname"><span class="pre">idx_to_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.idx_to_pos" title="Permalink to this definition"></a></dt>
<dd><p>Convert an array index to a position in mm along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.idx_to_slice">
<span class="sig-name descname"><span class="pre">idx_to_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.idx_to_slice" title="Permalink to this definition"></a></dt>
<dd><p>Convert an array index to a slice number along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.label_ax">
<span class="sig-name descname"><span class="pre">label_ax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_in_mm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xtick_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_ytick_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotate_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">major_ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minor_ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks_all_sides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_axis_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.label_ax" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.load" title="Permalink to this definition"></a></dt>
<dd><p>Load pixel array from image source. If already loaded and &lt;force&gt; 
is False, nothing will happen.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, the pixel array will be reloaded from source even if it 
has previously been loaded.</p>
</dd>
</dl>
<p>Data loading takes input from self.source and uses this to assign
self.data (as well as geometric properties, where relevant). The 
parameter self.source_type is set to a string indicating the type 
of source, which can be any of:</p>
<blockquote>
<div><dl class="simple">
<dt>“array”: </dt><dd><p>Data loaded from a numpy array in dicom-style orientation.</p>
</dd>
<dt>“nifti array”: </dt><dd><p>Data loaded from a numpy array in nifti-style orientation.</p>
</dd>
<dt>“nifti”: </dt><dd><p>Data loaded from a nifti file.</p>
</dd>
<dt>“dicom”: </dt><dd><p>Data loaded from one or more dicom file(s).</p>
</dd>
</dl>
</div></blockquote>
<p>The loading sequence is as follows:</p>
<blockquote>
<div><p>1. If self.source is a numpy array, self.data will be set to the
contents of self.source. If &lt;nifti_array&gt; was set to True when 
__init__() was called, self.source_type is set to “nifti array”;
otherwise, self.source_type is set to “array”.</p>
<p>2. If self.source is a string, this string is passed to
glob.glob().  The result is assigned to self.source, and 
is treated as a list of filepaths.  If the list contains a
single element, attempt to load a nifti file from this path
using the function load_nifti(). If the path points to a
valid nifti file, this will return a pixel array and affine
matrix, which are assigned to self.data and self.affine,
respectively. Set self.source_type to “nifti”.</p>
<p>3. If no data were loaded in step 2 (i.e. self.data is still None),
and self.source contains a single path, attempt to load from
a numpy binary file at this path using the function load_npy(). If
the path points to a valid numpy binary file, this will return
a pixel array, which is assigned to self.data. Set source_type
to either “nifti array” or “array”, depending on whether
&lt;nifti_array&gt; was set to True or False, respectively,
when __init__() was called.</p>
<p>4. If no data were loaded in step 4 (i.e. self.data is still None),
attempt to load from dicom file(s) or directory at the path(s) in
self.source using the function load_dicom().  If successful, this 
returns a pixel array, affine matrix, default greyscale window
centre and width, the last loaded pydicom.dataset.FileDataset 
object, and a dictionary mapping z positions to paths to the
dicom file for that slice. These outputs are used to assign 
self.data, self.affine, self.dicom_dataset, self._z_paths,
and self._z_instance_numbers; self.source_type is set to “dicom”.</p>
<p>5. If no data were loaded in step 5 (i.e. self.data is still None),
raise a RuntimeError.</p>
<p>6. If self.data contains a 2D array, convert this to 3D by adding
an extra axis.</p>
<ol class="arabic simple" start="7">
<li><p>Apply any downsampling as specificied in __init__().</p></li>
</ol>
<p>8. Run self.set_geometry() in order to compute geometric quantities
for this Image.</p>
<p>9. If a default window width and window centre were loaded from 
dicom, use these to set self.default_window to a greyscale window 
range.</p>
<p>10. If self.title is None and self.source is a filepath, infer
a title from the basename of this path.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.map_hu">
<span class="sig-name descname"><span class="pre">map_hu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'kv_to_mv'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.map_hu" title="Permalink to this definition"></a></dt>
<dd><p>Map radiodensities in Hounsfield units according to mapping function.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>mapping - str, default=’kv_to_mv’</dt><dd><p>Identifier of mapping function to be used.  Currently only
the VoxTox mapping from kV CT scan to MV CT scan is implemented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.match_size">
<span class="sig-name descname"><span class="pre">match_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.match_size" title="Permalink to this definition"></a></dt>
<dd><p>Match image size to that of a reference image.</p>
<p>After matching, the image voxels are in one-to-one correspondence
with those of the reference.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image: skrt.image.Image/None, default=None</dt><dd><p>Reference image, with which size is to be matched.</p>
</dd>
<dt>fill_value: float/None, default = None</dt><dd><p>Intensity value to be assigned to any voxels in the resized
image that are outside the original image.  If set to None,
the minimum intensity value of the original image is used.</p>
</dd>
<dt>method: str, default=’linear’</dt><dd><p>Interpolation method to use.  Valid values are ‘linear’ and
‘nearest’</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.match_voxel_size">
<span class="sig-name descname"><span class="pre">match_voxel_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'self'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.match_voxel_size" title="Permalink to this definition"></a></dt>
<dd><p>Resample to match z-axis voxel size with that of another Image
object.</p>
<dl class="simple">
<dt>Note: This method matches voxel size along z-axis only.</dt><dd><p>To match voxel sizes in all dimensions, use the function
skrt.images.match_image_voxel_sizes().</p>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">Image</span></dt><dd><p>Other image to which z-axis voxel size should be matched.</p>
</dd>
<dt>method<span class="classifier">str, default=”self”</span></dt><dd><dl class="simple">
<dt>String specifying the matching method. Can be any of:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“self”: </dt><dd><p>Match own z voxel size to that of &lt;image&gt;.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“coarse”: </dt><dd><p>Resample the image with the smaller z voxels to match
that of the image with larger z voxels.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“fine”: </dt><dd><p>Resample the image with the larger z voxels to match
that of the image with smaller z voxels.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_in_mm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_as</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mpl_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clb_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clb_label_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_xtick_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_ytick_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annotate_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">major_ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minor_ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks_all_sides</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_axis_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rois</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'contour'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">consensus_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_from_consensus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">consensus_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'blue'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">consensus_linewidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_on_roi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_bbox_to_anchor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lower</span> <span class="pre">left'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dose_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dose_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masked</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'black'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'quiver'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">df_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.plot" title="Permalink to this definition"></a></dt>
<dd><p>Plot a 2D slice of the image.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>view<span class="classifier">str/None, default=’x-y’</span></dt><dd><p>Orientation in which to plot the image. Can be any of ‘x-y’,
‘x-z’, ‘y-x’, ‘y-z’, ‘z-x’, and ‘z-y’.  If None, the initial
view is chosen to match the image orienation.</p>
</dd>
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number to plot. Takes precedence over &lt;idx&gt; and &lt;pos&gt; if not
None. If all of &lt;sl&gt;, &lt;idx&gt;, and &lt;pos&gt; are None, the central
slice will be plotted.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Index of the slice in the array to plot. Takes precendence over
&lt;pos&gt;.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Position in mm of the slice to plot. Will be rounded to the nearest
slice. Only used if &lt;sl&gt; and &lt;idx&gt; are both None.</p>
</dd>
<dt>standardised<span class="classifier">bool, default=True</span></dt><dd><p>If True, a standardised version of the image array will be plotted
such that the axis labels are correct.</p>
</dd>
<dt>scale_in_mm<span class="classifier">bool, default=True</span></dt><dd><p>If True, axis labels will be in mm; otherwise, they will be slice
numbers.</p>
</dd>
<dt>ax<span class="classifier">matplotlib.pyplot.Axes, default=None</span></dt><dd><p>Axes on which to plot. If None, new axes will be created.</p>
</dd>
<dt>gs<span class="classifier">matplotlib.gridspec.GridSpec, default=None</span></dt><dd><p>If not None and &lt;ax&gt; is None, new axes will be created on the
current matplotlib figure with this gridspec.</p>
</dd>
<dt>figsize<span class="classifier">float, default=None</span></dt><dd><p>Figure height in inches; only used if &lt;ax&gt; and &lt;gs&gt; are None.</p>
</dd>
<dt>zoom<span class="classifier">int/float/tuple, default=None</span></dt><dd><p>Factor by which to zoom in. If a single int or float is given,
the same zoom factor will be applied in all directions. If a tuple
of three values is given, these will be used as the zoom factors
in each direction in the order (x, y, z). If None, the image will
not be zoomed in.</p>
</dd>
<dt>zoom_centre<span class="classifier">tuple, default=None</span></dt><dd><p>Position around which zooming is applied. If None, the centre of
the image will be used.</p>
</dd>
<dt>colorbar<span class="classifier">int/bool, default=False</span></dt><dd><p>Indicate whether to display colour bar(s):
- 1 or True: colour bar for main image;
- 2: colour bars for main image and for any associated image
or overlay;
- 0 or False: no colour bar.</p>
</dd>
<dt>colorbar_label<span class="classifier">str, default=’HU’</span></dt><dd><p>Label for the colorbar, if drawn.</p>
</dd>
<dt>clb_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to pyplot.colorbar().</p>
</dd>
<dt>clb_label_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to colorbar.set_label().</p>
</dd>
<dt>intensity<span class="classifier">list, default=None</span></dt><dd><p>Two-item list containing min and max intensity for plotting. 
Supercedes ‘vmin’ and ‘vmax’ in &lt;mpl_kwargs&gt;.</p>
</dd>
<dt>mpl_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.imshow().</p>
</dd>
<dt>show<span class="classifier">bool, default=True</span></dt><dd><p>If True, the plotted figure will be shown via
matplotlib.pyplot.show().</p>
</dd>
<dt>title<span class="classifier">str, default=None</span></dt><dd><p>Custom title for the plot. If None, a title inferred from the image
filename will be used. If False or ‘’, no title will be added.</p>
</dd>
<dt>no_xlabel<span class="classifier">bool, default=False</span></dt><dd><p>If True, the x axis will not be labelled.</p>
</dd>
<dt>no_ylabel<span class="classifier">bool, default=False</span></dt><dd><p>If True, the y axis will not be labelled.</p>
</dd>
<dt>no_xticks<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks (and their labels) on the x axis will not be shown.</p>
</dd>
<dt>no_yticks<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks (and their labels) on the y axis will not be shown.</p>
</dd>
<dt>no_xtick_labels<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks on the x axis will not be labelled.</p>
</dd>
<dt>no_ytick_labels<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks on the y axis will not be labelled.</p>
</dd>
<dt>no_axis_label<span class="classifier">bool, default=False</span></dt><dd><p>If True, axis labels and axis values aren’t shown.</p>
</dd>
<dt>annotate_slice<span class="classifier">bool/str/dict/list, default=False</span></dt><dd><p>Specification of slice annotations:</p>
<ul class="simple">
<li><p>bool: annotate with slice position (scale_in_mm True)</p></li>
</ul>
<p>or number (scale_in_mm False), in default colour (white).</p>
<ul class="simple">
<li><p>str: annotate with slice position or number in colour</p></li>
</ul>
<p>specified by string.</p>
<ul class="simple">
<li><p>dict: annotation dictionary, containing keyword-value pairs</p></li>
</ul>
<p>to be passed to annotate() method of figure axes.  The
following defaults are defined:</p>
<blockquote>
<div><p>‘text’: slice position or number;
‘xy’: (0.05, 0.93)
‘xycoords’: ‘axes fraction’
‘color’: ‘white’
‘fontsize’: ‘large’</p>
</div></blockquote>
<ul class="simple">
<li><p>list: list of annotation dictionaries</p></li>
</ul>
<p>For information on all parameters that can be passed to
annotate() method, see:
<a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.html</a></p>
</dd>
<dt>major_ticks<span class="classifier">float, default=None</span></dt><dd><p>If not None, this value will be used as the interval between major
tick marks. Otherwise, automatic matplotlib axis tick spacing will
be used.</p>
</dd>
<dt>minor_ticks<span class="classifier">int, default=None</span></dt><dd><p>If None, no minor ticks will be plotted. Otherwise, this value will
be the number of minor tick divisions per major tick interval.</p>
</dd>
<dt>ticks_all_sides<span class="classifier">bool, default=False</span></dt><dd><p>If True, major (and minor if using) tick marks will be shown above
and to the right hand side of the plot as well as below and to the
left. The top/right ticks will not be labelled.</p>
</dd>
<dt>rois<span class="classifier">int/str, default=None</span></dt><dd><p>Option for which structure set should be plotted (if the Image
owns any structure sets). Can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>None: no structure sets will be plotted.</p></li>
<li><p>The index in self.structure_sets of the structure set
(e.g. to plot the newest structure set, use rois=-1)</p></li>
<li><p>‘all’: all structure sets will be plotted.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>roi_plot_type<span class="classifier">str, default=’contour’</span></dt><dd><p>ROI plotting type (see ROI.plot() for options).</p>
</dd>
<dt>roi_opacity<span class="classifier">float, default=None</span></dt><dd><p>Opacity to use if plotting ROI as mask (i.e. roi_plot_type
“mask”, “filled”, or “filled centroid”). If None, opacity
will be 1 by default for solid mask plots and 0.3 by default
for filled plots.</p>
</dd>
<dt>roi_linewidth<span class="classifier">float, default=None</span></dt><dd><p>Width of ROI contour lines. If None, the matplotlib default setting 
will be used.</p>
</dd>
<dt>consensus_type<span class="classifier">str, default=None</span></dt><dd><p>If not None, the consensus of all ROIs will be plotting rather than
plotting ROIs individually. Requires &lt;rois&gt; to be a single
StructureSet. Options are “majority”, “sum”, “overlap”, “staple”.</p>
</dd>
<dt>exclude_from_consensus<span class="classifier">str, default=None</span></dt><dd><p>If set to the name of an ROI and consensus_type is a valid 
consensus type, this ROI will be excluded from the consensus 
calculation and plotted separately on top of the consensus ROI.</p>
</dd>
<dt>consensus_color<span class="classifier">matplotlib color, default=”white”</span></dt><dd><p>Color in which to plot consensus contour.</p>
</dd>
<dt>consensus_linewidth<span class="classifier">float, default=None</span></dt><dd><p>Linewidth of consensus contour. If None, the default matplotlib
linewidth + 1 will be used (such that consensus contours are 
thicker than standard contours).</p>
</dd>
<dt>legend<span class="classifier">bool, default=False</span></dt><dd><p>If True, a legend will be drawn containing ROI names.</p>
</dd>
<dt>roi_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Extra arguments to provide to ROI plotting via the ROI.plot()
method.</p>
</dd>
<dt>centre_on_roi<span class="classifier">str, default=None</span></dt><dd><p>Name of ROI on which to centre, if no idx/sl/pos is given.
If &lt;zoom&gt; is given but no &lt;zoom_centre&gt;, the zoom will also centre
on this ROI.</p>
</dd>
<dt>legend_bbox_to_anchor<span class="classifier">tuple, default=None</span></dt><dd><p>Specify placement of ROI legend.
- If a four-element tuple, the elements specify</p>
<blockquote>
<div><p>(x, y, width, height) of the legend bounding box.</p>
</div></blockquote>
<ul class="simple">
<li><p>If a two-element tuple, the elements specify (x, y) of
the part of the legend bounding box specified by legend_loc.</p></li>
</ul>
</dd>
<dt>legend_loc<span class="classifier">str, default=’lower left’</span></dt><dd><p>Legend location for ROI legend.</p>
</dd>
<dt>dose<span class="classifier">skrt.dose.Dose / int, default=None</span></dt><dd><p>Dose field to overlay on the image. Can be either a skrt.dose.Dose
object or an integer referring to the 
dose at a given index in self.doses (e.g. to plot the last dose 
assigned to this Image, set dose=-1).</p>
</dd>
<dt>dose_opacity<span class="classifier">float, default=0.5</span></dt><dd><p>Opacity of overlaid dose field, if &lt;dose&gt; is not None.</p>
</dd>
<dt>dose_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Extra arguments to provide to the mpl_kwargs argument in the dose 
plotting method.</p>
</dd>
<dt>xlim, ylim<span class="classifier">tuples, default=None</span></dt><dd><p>Custom limits on the x and y axes of the plot.</p>
</dd>
<dt>mask<span class="classifier">Image/list/ROI/str/StructureSet, default=None</span></dt><dd><p>Image object representing a mask or a source from which
an Image object can be initialised.  In addition to the
sources accepted by the Image constructor, the source
may be an ROI, a list of ROIs or a StructureSet.  In the
latter cases, the mask image is derived from the ROI mask(s).</p>
</dd>
<dt>mask_threshold<span class="classifier">float, default=0.5</span></dt><dd><p>Threshold for mask data.  Values above and below this value are
set to True and False respectively.  Taken into account only
if the mask image has non-boolean data.</p>
</dd>
<dt>masked<span class="classifier">bool, default=True</span></dt><dd><p>If True and a mask is specified, the image is masked.</p>
</dd>
<dt>invert_mask<span class="classifier">bool, default=False</span></dt><dd><p>If True and a mask is applied, the mask will be inverted.</p>
</dd>
<dt>mask_color<span class="classifier">matplotlib color, default=”black”</span></dt><dd><p>color in which to plot masked areas.</p>
</dd>
<dt>jacobian<span class="classifier">skrt.registration.Jacobian, default=None</span></dt><dd><p>Jacobian determinannt to be overlaid on plot.  This parameter
is ignored if a non-null value is specified for dose.</p>
</dd>
<dt>jacobian_opacity<span class="classifier">float, default=0.8</span></dt><dd><p>Initial opacity of the overlaid jacobian determinant. Can later
be changed interactively.</p>
</dd>
<dt>jacobian_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.pyplot.imshow
for the jacobian determinant. For options, see:
<a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html</a></p>
<p>Some useful keywords are:</p>
<ul class="simple">
<li><p>‘cmap’: colormap (default=’jacobian’ - custom colour map).</p></li>
<li><p>‘interpolation’: interpolation method (default=’antialiased’)</p></li>
</ul>
</dd>
<dt>df_plot_type<span class="classifier">str, default=’quiver’</span></dt><dd><p>Option for initial plotting of deformation field. Can be ‘quiver’,
‘grid’, ‘x-displacement’, ‘y-displacement’,
‘z-displacement’, ‘3d-displacement’, or ‘none’.
All quantities relate to the mapping of points from
fixed image to moving image in image registration.</p>
</dd>
<dt>df_spacing<span class="classifier">int/tuple, default=30</span></dt><dd><p>Spacing between arrows on the quiver plot/gridlines on the grid
plot of a deformation field. Can be a single value for spacing in
all directions, or a tuple with values for (x, y, z). Dimensions
are mm if &lt;scale_in_mm&gt; is True, or voxels if &lt;scale_in_mm&gt; is
False.</p>
</dd>
<dt>df_opacity<span class="classifier">float, default=0.5</span></dt><dd><p>Initial opacity of the overlaid deformation field.</p>
</dd>
<dt>df<span class="classifier">str/skrt.registration.DeformationField/list, default=None</span></dt><dd><p>Source(s) of deformation field(s) to overlay on each plot.</p>
</dd>
<dt>df_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib when plotting
the deformation field.</p>
<p>For grid plotting options, see <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html</a>.
Some useful keywords are:</p>
<ul class="simple">
<li><p>‘linewidth’: default=2</p></li>
<li><p>‘color’: default=’green’</p></li>
</ul>
<p>For quiver plotting options, see <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html</a>.</p>
</dd>
<dt>roi_plot_type<span class="classifier">str, default=’contour’</span></dt><dd><p>Option for initial plot of ROIs. Can be ‘contour’, ‘mask’,
‘filled’, or ‘none’.</p>
</dd>
<dt>grid<span class="classifier">string/nifti/array/list, default=None</span></dt><dd><p>Source(s) of grid array(s) to overlay on image
(see valid image sources for &lt;images&gt;).</p>
</dd>
<dt>grid_opacity<span class="classifier">float, default=1.0</span></dt><dd><p>Opacity of the overlaid grid.</p>
</dd>
<dt>grid_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.pyplot.imshow
for the grid. See <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html</a>
for options.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.pos_to_idx">
<span class="sig-name descname"><span class="pre">pos_to_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.pos_to_idx" title="Permalink to this definition"></a></dt>
<dd><p>Convert a position in mm to an array index along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.pos_to_slice">
<span class="sig-name descname"><span class="pre">pos_to_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.pos_to_slice" title="Permalink to this definition"></a></dt>
<dd><p>Convert a position in mm to a slice number along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.print_geometry">
<span class="sig-name descname"><span class="pre">print_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">float_format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.4f'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.print_geometry" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.remove_bolus">
<span class="sig-name descname"><span class="pre">remove_bolus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bolus_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.remove_bolus" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Attempt to remove bolus from image.</p>
<p>In treatment planning, ROIs labelled as bolus may be defined on
the skin, and are assigned a radiodensity of water (zero) to help guide
the treatment optimiser.  The original image is approximately
recovered by overwriting with the radiodensity of air.</p>
<p><strong>Parameters:</strong>
structure_set : skrt.structures.StructureSet</p>
<blockquote>
<div><p>Structure set to search for ROIs labelled as bolus.  If None,
the image’s earliest associated structure set is used.</p>
</div></blockquote>
<dl class="simple">
<dt>bolus_names<span class="classifier">list, default=None</span></dt><dd><p>List of names, optionally including wildcards, with which
bolus may be labelled.  If None, use
skrt.image._default_bolus_names.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>intensity<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value to be assigned to voxels of ROI labelled as bolus.
If None, use image’s minimum value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.resample">
<span class="sig-name descname"><span class="pre">resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.resample" title="Permalink to this definition"></a></dt>
<dd><p>Resample image to have particular voxel sizes.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>voxel_size: int/float/tuple/list, default =(1, 1, 1)</dt><dd><p>Voxel size to which image is to be resampled.  If voxel_size is
a tuple or list, then it’s taken to specify voxel sizes
in mm in the order x, y, z.  If voxel_size is an int or float,
then it’s taken to specify the voxel size in mm along all axes.</p>
</dd>
<dt>order: int, default = 1</dt><dd><p>Order of the b-spline used in interpolating voxel intensity values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.rescale">
<span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.rescale" title="Permalink to this definition"></a></dt>
<dd><p>Linearly rescale image greyscale values,
so that they span a specified range.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>v_min: float, default=0.0</dt><dd><p>Minimum greyscale value after rescaling.</p>
</dd>
<dt>v_max: float, default=1.0</dt><dd><p>Maximum greyscale value after rescaling.</p>
</dd>
<dt>constant: float, default=0.5</dt><dd><p>Greyscale value to assign after rescaling if all values
in the original image are the same.  If None,
original value is kept.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.resize">
<span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_size_unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.resize" title="Permalink to this definition"></a></dt>
<dd><p>Resize image to specified image size, voxel size and origin.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image_size<span class="classifier">tuple/list/None, default=None</span></dt><dd><p>Image sizes in order (x,y,z) to which image is to be resized.
If None, the image’s existing size in mm is kept.  If a value
in the tuple/list is None, the relevant existing value is
kept.  The unit of measurement (‘voxel’ or ‘mm’) is specified
via image_size_unit.  If the size is in mm, and isn’t an
integer multiple of voxel_size, resizing won’t be exact.</p>
</dd>
<dt>origin<span class="classifier">tuple/list/None, default=None</span></dt><dd><p>Origin position in mm in order (x, y, z).  If None, the image’s
existing origin is kept.  If a value in the tuple/list is None,
the relevant existing value is kept.  Disregarded if centre
isn’t None, or if keep_centre is True.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple/list/None, default=None</span></dt><dd><p>Voxel sizes in mm in order (x, y, z).  If None, the image’s
existing voxel size is kept.  If a value in the tuple/list is None,
the relevant existing value is kept.</p>
</dd>
<dt>fill_value: float/None, default = None</dt><dd><p>Intensity value to be assigned to any voxels in the resized
image that are outside the original image.  If set to None,
the minimum intensity value of the original image is used.</p>
</dd>
<dt>image_size_unit: str, default=None</dt><dd><p>Unit of measurement (‘voxel’ or ‘mm’) for image_size.  If None,
use ‘voxel’.</p>
</dd>
<dt>centre<span class="classifier">tuple/list/None, default=None</span></dt><dd><p>Position (x, y, z) in mm in the original image to be set as
centre for the resized image.  Disregarded if None.  Otherwise
takes priority over origin and keep_centre.  If a value in
the tuple/list is None, the relevant value from the original
image centre is kept.</p>
</dd>
<dt>keep_centre: bool, default=False</dt><dd><p>If True, make the centre of the initial image the centre of
the resized image, disregarding the value passed to origin.
Disregarded if the value of the centre parameter isn’t None.</p>
</dd>
<dt>method: str, default=’linear’</dt><dd><p>Interpolation method to use.  Valid values are ‘linear’ and
‘nearest’</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.select_foreground">
<span class="sig-name descname"><span class="pre">select_foreground</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dxy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.select_foreground" title="Permalink to this definition"></a></dt>
<dd><p>Modify image to show intensity information only for foreground.</p>
<p>Slice by slice, the foreground is taken to correspond to the
largest region of contiguous pixels above a threshold value.
Voxels outside the foreground region are all assigned the
same same (background) intensity value.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value above which pixels in a slice are assigned to
regions for determination of foreground.  If None, use value
of Defaults().foreground_threshold.  If still None, use
Otsu threshold.</p>
</dd>
<dt>convex_hull<span class="classifier">bool, default=False</span></dt><dd><p>If True, create mask from the convex hulls of the
slice foreground masks initially obtained.</p>
</dd>
<dt>fill_holes<span class="classifier">bool, default=False</span></dt><dd><p>If False, fill holes in the slice foreground masks initially
obtained.</p>
</dd>
<dt>background<span class="classifier">int/float, default=None</span></dt><dd><p>Intensity value to be assigned to background voxels.  If
None, the image’s minimum value is used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.set_ax">
<span class="sig-name descname"><span class="pre">set_ax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.set_ax" title="Permalink to this definition"></a></dt>
<dd><p>Set up axes for this Image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.set_geometry">
<span class="sig-name descname"><span class="pre">set_geometry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.set_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Set geometric properties for this image. Should be called once image
data has been loaded. Sets the following properties:</p>
<blockquote>
<div><dl class="simple">
<dt>Affine matrix (self.affine): </dt><dd><p>4x4 affine matrix. If initially None, this is computed 
from self.voxel_size and self.origin.</p>
</dd>
<dt>Voxel sizes (self.voxel_size):</dt><dd><p>List of [x, y, z] voxel sizes in mm. If initially None, this 
is computed from self.affine.</p>
</dd>
<dt>Origin position (self.origin):</dt><dd><p>List of [x, y, z] origin coordinates in mm. If initiall None,
this is computed from self.affine.</p>
</dd>
<dt>Number of voxels (self.n_voxels):</dt><dd><p>List of number of voxels in the [x, y, z] directions. Computed 
from self.data.shape.</p>
</dd>
<dt>Limits (self.lims):</dt><dd><p>List of minimum and maximum array positions in the [x, y, z]
directions (corresponding the centres of the first and last 
voxels). Calculated from standardised origin, voxel sizes, 
and image shape.</p>
</dd>
<dt>Image extent (self.image_extent):</dt><dd><p>List of minimum and maximum positions of the edges of the array
in the [x, y, z] directions. Calculated from self.lims +/-
half a voxel size.</p>
</dd>
<dt>Plot extent (self.plot_extent):</dt><dd><p>Dict of plot extents for each orientation. Given in the form
of a list [x1, x2, y1, y2], which is the format needed for 
the &lt;extent&gt; argument for matplotlib plotting.</p>
</dd>
<dt>Image sizes (self.image_size):</dt><dd><p>List of [x, y, z] image sizes in mm.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.slice_to_idx">
<span class="sig-name descname"><span class="pre">slice_to_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.slice_to_idx" title="Permalink to this definition"></a></dt>
<dd><p>Convert a slice number to an array index along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.slice_to_pos">
<span class="sig-name descname"><span class="pre">slice_to_pos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.slice_to_pos" title="Permalink to this definition"></a></dt>
<dd><p>Convert a slice number to a position in mm along a given axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.standardise_data">
<span class="sig-name descname"><span class="pre">standardise_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.standardise_data" title="Permalink to this definition"></a></dt>
<dd><p>Manipulate data array and affine matrix into standard dicom
orientation, where [column, row, slice] corresponds to the [x, y, z] 
axes; assign results to self._sdata and self._saffine, respectively.
Standardised voxel sizes (self._svoxel_size) and origin position
(self._sorigin) will also be inferred from self._affine.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resample</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fine'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.transform" title="Permalink to this definition"></a></dt>
<dd><p>Apply three-dimensional similarity transform using scikit-image.</p>
<p>The image is first translated, then is scaled and rotated
about the centre coordinates</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>scale<span class="classifier">float, default=1</span></dt><dd><p>Scaling factor.</p>
</dd>
<dt>translation<span class="classifier">list, default=[0, 0, 0]</span></dt><dd><p>Translation in mm in the [x, y, z] directions.</p>
</dd>
<dt>rotation<span class="classifier">float, default=0</span></dt><dd><p>Euler angles in degrees by which to rotate the image.
Angles are in the order pitch (rotation about x-axis),
yaw (rotation about y-axis), roll (rotation about z-axis).</p>
</dd>
<dt>centre<span class="classifier">list, default=[0, 0, 0]</span></dt><dd><p>Coordinates in mm in [x, y, z] about which to perform rotation
and scaling of translated image.</p>
</dd>
<dt>resample: float/string, default=’coarse’</dt><dd><p>Resampling to be performed before image transformation.
If resample is a float, then the image is resampled to that
this is the voxel size in mm along all axes.  If the
transformation involves scaling or rotation in an image
projection where voxels are non-square:
if resample is ‘fine’ then voxels are resampled to have
their smallest size along all axes;
if resample is ‘coarse’ then voxels are resampled to have
their largest size along all axes.</p>
</dd>
<dt>restore: bool, default=True</dt><dd><p>In case that image has been resampled:
if True, restore original voxel size for transformed iamge;
if False, keep resampled voxel size for transformed image.</p>
</dd>
<dt>order: int, default = 1</dt><dd><p>Order of the b-spline used in interpolating voxel intensity values.</p>
</dd>
<dt>fill_value: float/None, default = None</dt><dd><p>Intensity value to be assigned to any voxels in the resized
image that are outside the original image.  If set to None,
the minimum intensity value of the original image is used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.translate_origin">
<span class="sig-name descname"><span class="pre">translate_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.translate_origin" title="Permalink to this definition"></a></dt>
<dd><p>Translate origin, effectively changing image position.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>translation<span class="classifier">list, default=[0, 0, 0]</span></dt><dd><p>Translation in mm in the [x, y, z] directions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.view" title="Permalink to this definition"></a></dt>
<dd><p>View self with BetterViewer along with any additional images in 
&lt;images&gt;. Any <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> will be passed to BetterViewer
initialisation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">write_geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nifti_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header_source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patient_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patient_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_uid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.write" title="Permalink to this definition"></a></dt>
<dd><p>Write image data to a file. The filetype will automatically be
set based on the extension of &lt;outname&gt;:</p>
<blockquote>
<div><p>(a) <code class="docutils literal notranslate"><span class="pre">*</span></code>.nii or <code class="docutils literal notranslate"><span class="pre">*</span></code>.nii.gz: Will write to a nifti file with
canonical nifti array and affine matrix.</p>
<p>(b) <code class="docutils literal notranslate"><span class="pre">*</span></code>.npy: Will write the dicom-style numpy array to a binary
filem unless &lt;nifti_array&gt; is True, in which case the canonical
nifti-style array will be written. If &lt;write_geometry&gt; is True,
a text file containing the voxel sizes and origin position will
also be written in the same directory.</p>
<p>(c) <code class="docutils literal notranslate"><span class="pre">*</span></code>.dcm: Will write to dicom file(s) (1 file per x-y slice)
in the directory of the filename given, named by slice number.</p>
<p>(d) No extension: Will create a directory at &lt;outname&gt; and write
to dicom file(s) in that directory (1 file per x-y slice), named
by slice number.</p>
</div></blockquote>
<p>If (c) or (d) (i.e. writing to dicom), the header data will be set in
one of three ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>If the input source was not a dicom, &lt;dicom_for_header&gt; is None,
a brand new dicom with freshly generated UIDs will be created.</p></li>
<li><p>If &lt;dicom_for_header&gt; is set to the path to a dicom file, that
dicom file will be used as the header.</p></li>
<li><p>Otherwise, if the input source was a dicom or directory
containing dicoms, the header information will be taken from the
input dicom file.</p></li>
</ul>
</div></blockquote>
<p>In addition, when writing to dicom, the header obtained as outlined
above will be updated via attribute-value pairs passed
via the dictionary header_extras.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.Image.zoom_ax">
<span class="sig-name descname"><span class="pre">zoom_ax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.Image.zoom_ax" title="Permalink to this definition"></a></dt>
<dd><p>Zoom in on axes if needed.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skrt.image.ImageComparison">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">ImageComparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlay'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#skrt.image.Image" title="skrt.image.Image"><code class="xref py py-class docutils literal notranslate"><span class="pre">Image</span></code></a></p>
<p>Plot comparisons of two images and calculate comparison metrics.</p>
<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlay'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialise from a medical image source.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>path<span class="classifier">str/array/Nifti1Image, default = “”</span></dt><dd><p>Source of image data. Can be either:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>A string, optionally with wildcards,
containing the path to one or multiple dicom files,
the path to a directory containg dicom files,
or the path to a single nifti file;</p></li>
<li><p>A list of paths, optionally with wildcards, to dicom files;</p></li>
<li><p>A string, optionally containing wildcards, containing
the path to a single numpy file containing a 2D or 3D array;</p></li>
<li><p>A 2D or 3D numpy array;</p></li>
<li><p>A nibabel.nifti1.Nifti1Image object;</p></li>
<li><p>An existing Image object to be cloned; in this case, all 
other input args except &lt;title&gt; will be ignored, as these 
will be taken from the existing Image.</p></li>
</ol>
</div></blockquote>
<p>Notes:</p>
<ol class="arabic simple">
<li><p>If path points to a single file, all files in the same
directory as this file are considered also.</p></li>
</ol>
<p>2. When path resolves to multiple dicom files, only files
that match the values of the first file for the dicom
attributes: “StudyInstanceUID”, “SeriesNumber”, “Modality”,
“ImageOrientationPatient”.  When path points to a single file
in a directory with others, this file is taken as the first
file.  Otherwise, files are sorted according to natural sort
order (so “2.dcm” before “11.dcm”).  To load images from files
in a single directory (or in a directory tree) that may have
different values for these, it could be better to use the
skrt.patient.Patient class:</p>
<p>from skrt import Patient
p = Patient(“path/to/directory”, unsorted_dicom=True)</p>
<p>For more details, see documentation of Patient class.</p>
</dd>
<dt>load<span class="classifier">bool, default=True</span></dt><dd><p>If True, the image data will be immediately loaded. Otherwise, it
can be loaded later with the load() method.</p>
</dd>
<dt>title<span class="classifier">str, default=None</span></dt><dd><p>Title to use when plotting the image. If None and &lt;source&gt; is a
path, a title will be automatically generated from the filename.</p>
</dd>
<dt>affine<span class="classifier">4x4 array, default=None</span></dt><dd><p>Array containing the affine matrix to use if &lt;source&gt; is a numpy
array or path to a numpy file. If not None, this takes precendence
over &lt;voxel_size&gt; and &lt;origin&gt;.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple, default=(1, 1, 1)</span></dt><dd><p>Voxel sizes in mm in order (x, y, z) to use if &lt;source&gt; is a numpy
array or path to a numpy file and &lt;affine&gt; is not provided.</p>
</dd>
<dt>origin<span class="classifier">tuple, default=(0, 0, 0)</span></dt><dd><p>Origin position in mm in order (x, y, z) to use if &lt;source&gt; is a
numpy array or path to a numpy file and &lt;affine&gt; is not provided.</p>
</dd>
<dt>nifti_array<span class="classifier">bool, default=False</span></dt><dd><p>If True and &lt;source&gt; is a numpy array or numpy file, the array
will be treated as a nifti-style array, i.e. (x, y, z) in
(row, column, slice), as opposed to dicom style.</p>
</dd>
<dt>downsample<span class="classifier">int/list, default=None</span></dt><dd><p>Amount by which to downsample the image. Can be a single value for
all axes, or a list containing downsampling amounts in order
(x, y, z).</p>
</dd>
<dt>dtype<span class="classifier">type, default=None</span></dt><dd><p>Type to which loaded data should be cast.</p>
</dd>
<dt>auto_timestamp<span class="classifier">bool default=False</span></dt><dd><p>If true and no valid timestamp is found within the path string,
timestamp generated from current date and time.</p>
</dd>
<dt>default_intensity<span class="classifier">tuple,None default=(-200, 300)</span></dt><dd><p>Default intensity range for image display.  This can
be specified as a two-element tuple, giving minimum and maximum,
or if set to None then intensity range used is from the
minimum of zero and the image minimum, to the image maximum.
If WindowCenter and WindowWidth are defined in a
DICOM source file, these values will be used instead to
define the default intensity range.</p>
</dd>
<dt>log_level: str/int/None, default=None</dt><dd><p>Severity level for event logging.  If the value is None,
log_level is set to the value of skrt.core.Defaults().log_level.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.get_difference">
<span class="sig-name descname"><span class="pre">get_difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.get_difference" title="Permalink to this definition"></a></dt>
<dd><p>Get array containing difference between two Images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.get_dta">
<span class="sig-name descname"><span class="pre">get_dta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.get_dta" title="Permalink to this definition"></a></dt>
<dd><p>Compute distance to agreement array on current slice.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.get_gamma">
<span class="sig-name descname"><span class="pre">get_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dta_crit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_crit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reset_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.get_gamma" title="Permalink to this definition"></a></dt>
<dd><p>Get gamma index on current slice.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.get_plot_aspect_ratio">
<span class="sig-name descname"><span class="pre">get_plot_aspect_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.get_plot_aspect_ratio" title="Permalink to this definition"></a></dt>
<dd><p>Get relative width of first image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.load" title="Permalink to this definition"></a></dt>
<dd><p>Load associated images, and set array limits in [x, y, z] directions.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>force<span class="classifier">bool, default=True</span></dt><dd><p>If True, associated images will be reloaded from source, even if
previously loaded.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x-y'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_in_mm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mpl_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cb_splits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlay_opacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlay_legend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlay_legend_bbox_to_anchor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlay_legend_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_mse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dta_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dta_crit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diff_crit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_cached_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.plot" title="Permalink to this definition"></a></dt>
<dd><p>Plot a 2D slice of the image.</p>
<p><strong>Parameters:</strong></p>
<dl>
<dt>view<span class="classifier">str/None, default=’x-y’</span></dt><dd><p>Orientation in which to plot the image. Can be any of ‘x-y’,
‘x-z’, ‘y-x’, ‘y-z’, ‘z-x’, and ‘z-y’.  If None, the initial
view is chosen to match the image orienation.</p>
</dd>
<dt>sl<span class="classifier">int, default=None</span></dt><dd><p>Slice number to plot. Takes precedence over &lt;idx&gt; and &lt;pos&gt; if not
None. If all of &lt;sl&gt;, &lt;idx&gt;, and &lt;pos&gt; are None, the central
slice will be plotted.</p>
</dd>
<dt>idx<span class="classifier">int, default=None</span></dt><dd><p>Index of the slice in the array to plot. Takes precendence over
&lt;pos&gt;.</p>
</dd>
<dt>pos<span class="classifier">float, default=None</span></dt><dd><p>Position in mm of the slice to plot. Will be rounded to the nearest
slice. Only used if &lt;sl&gt; and &lt;idx&gt; are both None.</p>
</dd>
<dt>standardised<span class="classifier">bool, default=True</span></dt><dd><p>If True, a standardised version of the image array will be plotted
such that the axis labels are correct.</p>
</dd>
<dt>scale_in_mm<span class="classifier">bool, default=True</span></dt><dd><p>If True, axis labels will be in mm; otherwise, they will be slice
numbers.</p>
</dd>
<dt>ax<span class="classifier">matplotlib.pyplot.Axes, default=None</span></dt><dd><p>Axes on which to plot. If None, new axes will be created.</p>
</dd>
<dt>gs<span class="classifier">matplotlib.gridspec.GridSpec, default=None</span></dt><dd><p>If not None and &lt;ax&gt; is None, new axes will be created on the
current matplotlib figure with this gridspec.</p>
</dd>
<dt>figsize<span class="classifier">float, default=None</span></dt><dd><p>Figure height in inches; only used if &lt;ax&gt; and &lt;gs&gt; are None.</p>
</dd>
<dt>zoom<span class="classifier">int/float/tuple, default=None</span></dt><dd><p>Factor by which to zoom in. If a single int or float is given,
the same zoom factor will be applied in all directions. If a tuple
of three values is given, these will be used as the zoom factors
in each direction in the order (x, y, z). If None, the image will
not be zoomed in.</p>
</dd>
<dt>zoom_centre<span class="classifier">tuple, default=None</span></dt><dd><p>Position around which zooming is applied. If None, the centre of
the image will be used.</p>
</dd>
<dt>colorbar<span class="classifier">int/bool, default=False</span></dt><dd><p>Indicate whether to display colour bar(s):
- 1 or True: colour bar for main image;
- 2: colour bars for main image and for any associated image
or overlay;
- 0 or False: no colour bar.</p>
</dd>
<dt>colorbar_label<span class="classifier">str, default=’HU’</span></dt><dd><p>Label for the colorbar, if drawn.</p>
</dd>
<dt>clb_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to pyplot.colorbar().</p>
</dd>
<dt>clb_label_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to colorbar.set_label().</p>
</dd>
<dt>intensity<span class="classifier">list, default=None</span></dt><dd><p>Two-item list containing min and max intensity for plotting. 
Supercedes ‘vmin’ and ‘vmax’ in &lt;mpl_kwargs&gt;.</p>
</dd>
<dt>mpl_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.imshow().</p>
</dd>
<dt>show<span class="classifier">bool, default=True</span></dt><dd><p>If True, the plotted figure will be shown via
matplotlib.pyplot.show().</p>
</dd>
<dt>title<span class="classifier">str, default=None</span></dt><dd><p>Custom title for the plot. If None, a title inferred from the image
filename will be used. If False or ‘’, no title will be added.</p>
</dd>
<dt>no_xlabel<span class="classifier">bool, default=False</span></dt><dd><p>If True, the x axis will not be labelled.</p>
</dd>
<dt>no_ylabel<span class="classifier">bool, default=False</span></dt><dd><p>If True, the y axis will not be labelled.</p>
</dd>
<dt>no_xticks<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks (and their labels) on the x axis will not be shown.</p>
</dd>
<dt>no_yticks<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks (and their labels) on the y axis will not be shown.</p>
</dd>
<dt>no_xtick_labels<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks on the x axis will not be labelled.</p>
</dd>
<dt>no_ytick_labels<span class="classifier">bool, default=False</span></dt><dd><p>If True, ticks on the y axis will not be labelled.</p>
</dd>
<dt>no_axis_label<span class="classifier">bool, default=False</span></dt><dd><p>If True, axis labels and axis values aren’t shown.</p>
</dd>
<dt>annotate_slice<span class="classifier">bool/str/dict/list, default=False</span></dt><dd><p>Specification of slice annotations:</p>
<ul class="simple">
<li><p>bool: annotate with slice position (scale_in_mm True)</p></li>
</ul>
<p>or number (scale_in_mm False), in default colour (white).</p>
<ul class="simple">
<li><p>str: annotate with slice position or number in colour</p></li>
</ul>
<p>specified by string.</p>
<ul class="simple">
<li><p>dict: annotation dictionary, containing keyword-value pairs</p></li>
</ul>
<p>to be passed to annotate() method of figure axes.  The
following defaults are defined:</p>
<blockquote>
<div><p>‘text’: slice position or number;
‘xy’: (0.05, 0.93)
‘xycoords’: ‘axes fraction’
‘color’: ‘white’
‘fontsize’: ‘large’</p>
</div></blockquote>
<ul class="simple">
<li><p>list: list of annotation dictionaries</p></li>
</ul>
<p>For information on all parameters that can be passed to
annotate() method, see:
<a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.annotate.html</a></p>
</dd>
<dt>major_ticks<span class="classifier">float, default=None</span></dt><dd><p>If not None, this value will be used as the interval between major
tick marks. Otherwise, automatic matplotlib axis tick spacing will
be used.</p>
</dd>
<dt>minor_ticks<span class="classifier">int, default=None</span></dt><dd><p>If None, no minor ticks will be plotted. Otherwise, this value will
be the number of minor tick divisions per major tick interval.</p>
</dd>
<dt>ticks_all_sides<span class="classifier">bool, default=False</span></dt><dd><p>If True, major (and minor if using) tick marks will be shown above
and to the right hand side of the plot as well as below and to the
left. The top/right ticks will not be labelled.</p>
</dd>
<dt>rois<span class="classifier">int/str, default=None</span></dt><dd><p>Option for which structure set should be plotted (if the Image
owns any structure sets). Can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>None: no structure sets will be plotted.</p></li>
<li><p>The index in self.structure_sets of the structure set
(e.g. to plot the newest structure set, use rois=-1)</p></li>
<li><p>‘all’: all structure sets will be plotted.</p></li>
</ul>
</div></blockquote>
</dd>
<dt>roi_plot_type<span class="classifier">str, default=’contour’</span></dt><dd><p>ROI plotting type (see ROI.plot() for options).</p>
</dd>
<dt>roi_opacity<span class="classifier">float, default=None</span></dt><dd><p>Opacity to use if plotting ROI as mask (i.e. roi_plot_type
“mask”, “filled”, or “filled centroid”). If None, opacity
will be 1 by default for solid mask plots and 0.3 by default
for filled plots.</p>
</dd>
<dt>roi_linewidth<span class="classifier">float, default=None</span></dt><dd><p>Width of ROI contour lines. If None, the matplotlib default setting 
will be used.</p>
</dd>
<dt>consensus_type<span class="classifier">str, default=None</span></dt><dd><p>If not None, the consensus of all ROIs will be plotting rather than
plotting ROIs individually. Requires &lt;rois&gt; to be a single
StructureSet. Options are “majority”, “sum”, “overlap”, “staple”.</p>
</dd>
<dt>exclude_from_consensus<span class="classifier">str, default=None</span></dt><dd><p>If set to the name of an ROI and consensus_type is a valid 
consensus type, this ROI will be excluded from the consensus 
calculation and plotted separately on top of the consensus ROI.</p>
</dd>
<dt>consensus_color<span class="classifier">matplotlib color, default=”white”</span></dt><dd><p>Color in which to plot consensus contour.</p>
</dd>
<dt>consensus_linewidth<span class="classifier">float, default=None</span></dt><dd><p>Linewidth of consensus contour. If None, the default matplotlib
linewidth + 1 will be used (such that consensus contours are 
thicker than standard contours).</p>
</dd>
<dt>legend<span class="classifier">bool, default=False</span></dt><dd><p>If True, a legend will be drawn containing ROI names.</p>
</dd>
<dt>roi_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Extra arguments to provide to ROI plotting via the ROI.plot()
method.</p>
</dd>
<dt>centre_on_roi<span class="classifier">str, default=None</span></dt><dd><p>Name of ROI on which to centre, if no idx/sl/pos is given.
If &lt;zoom&gt; is given but no &lt;zoom_centre&gt;, the zoom will also centre
on this ROI.</p>
</dd>
<dt>legend_bbox_to_anchor<span class="classifier">tuple, default=None</span></dt><dd><p>Specify placement of ROI legend.
- If a four-element tuple, the elements specify</p>
<blockquote>
<div><p>(x, y, width, height) of the legend bounding box.</p>
</div></blockquote>
<ul class="simple">
<li><p>If a two-element tuple, the elements specify (x, y) of
the part of the legend bounding box specified by legend_loc.</p></li>
</ul>
</dd>
<dt>legend_loc<span class="classifier">str, default=’lower left’</span></dt><dd><p>Legend location for ROI legend.</p>
</dd>
<dt>dose<span class="classifier">skrt.dose.Dose / int, default=None</span></dt><dd><p>Dose field to overlay on the image. Can be either a skrt.dose.Dose
object or an integer referring to the 
dose at a given index in self.doses (e.g. to plot the last dose 
assigned to this Image, set dose=-1).</p>
</dd>
<dt>dose_opacity<span class="classifier">float, default=0.5</span></dt><dd><p>Opacity of overlaid dose field, if &lt;dose&gt; is not None.</p>
</dd>
<dt>dose_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Extra arguments to provide to the mpl_kwargs argument in the dose 
plotting method.</p>
</dd>
<dt>xlim, ylim<span class="classifier">tuples, default=None</span></dt><dd><p>Custom limits on the x and y axes of the plot.</p>
</dd>
<dt>mask<span class="classifier">Image/list/ROI/str/StructureSet, default=None</span></dt><dd><p>Image object representing a mask or a source from which
an Image object can be initialised.  In addition to the
sources accepted by the Image constructor, the source
may be an ROI, a list of ROIs or a StructureSet.  In the
latter cases, the mask image is derived from the ROI mask(s).</p>
</dd>
<dt>mask_threshold<span class="classifier">float, default=0.5</span></dt><dd><p>Threshold for mask data.  Values above and below this value are
set to True and False respectively.  Taken into account only
if the mask image has non-boolean data.</p>
</dd>
<dt>masked<span class="classifier">bool, default=True</span></dt><dd><p>If True and a mask is specified, the image is masked.</p>
</dd>
<dt>invert_mask<span class="classifier">bool, default=False</span></dt><dd><p>If True and a mask is applied, the mask will be inverted.</p>
</dd>
<dt>mask_color<span class="classifier">matplotlib color, default=”black”</span></dt><dd><p>color in which to plot masked areas.</p>
</dd>
<dt>jacobian<span class="classifier">skrt.registration.Jacobian, default=None</span></dt><dd><p>Jacobian determinannt to be overlaid on plot.  This parameter
is ignored if a non-null value is specified for dose.</p>
</dd>
<dt>jacobian_opacity<span class="classifier">float, default=0.8</span></dt><dd><p>Initial opacity of the overlaid jacobian determinant. Can later
be changed interactively.</p>
</dd>
<dt>jacobian_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.pyplot.imshow
for the jacobian determinant. For options, see:
<a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html</a></p>
<p>Some useful keywords are:</p>
<ul class="simple">
<li><p>‘cmap’: colormap (default=’jacobian’ - custom colour map).</p></li>
<li><p>‘interpolation’: interpolation method (default=’antialiased’)</p></li>
</ul>
</dd>
<dt>df_plot_type<span class="classifier">str, default=’quiver’</span></dt><dd><p>Option for initial plotting of deformation field. Can be ‘quiver’,
‘grid’, ‘x-displacement’, ‘y-displacement’,
‘z-displacement’, ‘3d-displacement’, or ‘none’.
All quantities relate to the mapping of points from
fixed image to moving image in image registration.</p>
</dd>
<dt>df_spacing<span class="classifier">int/tuple, default=30</span></dt><dd><p>Spacing between arrows on the quiver plot/gridlines on the grid
plot of a deformation field. Can be a single value for spacing in
all directions, or a tuple with values for (x, y, z). Dimensions
are mm if &lt;scale_in_mm&gt; is True, or voxels if &lt;scale_in_mm&gt; is
False.</p>
</dd>
<dt>df_opacity<span class="classifier">float, default=0.5</span></dt><dd><p>Initial opacity of the overlaid deformation field.</p>
</dd>
<dt>df<span class="classifier">str/skrt.registration.DeformationField/list, default=None</span></dt><dd><p>Source(s) of deformation field(s) to overlay on each plot.</p>
</dd>
<dt>df_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib when plotting
the deformation field.</p>
<p>For grid plotting options, see <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html</a>.
Some useful keywords are:</p>
<ul class="simple">
<li><p>‘linewidth’: default=2</p></li>
<li><p>‘color’: default=’green’</p></li>
</ul>
<p>For quiver plotting options, see <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.quiver.html</a>.</p>
</dd>
<dt>roi_plot_type<span class="classifier">str, default=’contour’</span></dt><dd><p>Option for initial plot of ROIs. Can be ‘contour’, ‘mask’,
‘filled’, or ‘none’.</p>
</dd>
<dt>grid<span class="classifier">string/nifti/array/list, default=None</span></dt><dd><p>Source(s) of grid array(s) to overlay on image
(see valid image sources for &lt;images&gt;).</p>
</dd>
<dt>grid_opacity<span class="classifier">float, default=1.0</span></dt><dd><p>Opacity of the overlaid grid.</p>
</dd>
<dt>grid_kwargs<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary of keyword arguments to pass to matplotlib.pyplot.imshow
for the grid. See <a class="reference external" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html</a>
for options.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.set_slices">
<span class="sig-name descname"><span class="pre">set_slices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">view</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_cached_slices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.set_slices" title="Permalink to this definition"></a></dt>
<dd><p>Get slice of each image and set to self.slices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skrt.image.ImageComparison.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.ImageComparison.view" title="Permalink to this definition"></a></dt>
<dd><p>View self with BetterViewer.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.checked_crop_limits">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">checked_crop_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">crop_limits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.checked_crop_limits" title="Permalink to this definition"></a></dt>
<dd><p>Check input crop limits, returning (xlim, ylim, zlim) tuple
that can be passed to skrt.image.Image.crop().</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>crop_limits<span class="classifier">float/tuple/list/None default=None</span></dt><dd><p>Specification of crop limits:</p>
<ul class="simple">
<li><p>If a float or a one-element tuple or list, crop limits
along each axis are taken to be minus and plus the 
value given.</p></li>
<li><p>If a three-element tuple or list, the three elements are
taken to correspond to x, y, z limits; an element that is
a float or a one-element tuple or list is taken to indicate
limits along the relevant axis of minus and plus the value given.</p></li>
<li><p>For all other inputs, a value of (None, None, None) is returned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.crop_by_amounts">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">crop_by_amounts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.crop_by_amounts" title="Permalink to this definition"></a></dt>
<dd><p>Crop image or ROI by the amounts dx, dy, dz in mm.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>obj<span class="classifier">skrt.image.Image/skrt.structures.ROI</span></dt><dd><p>Object (Image or ROI) for which cropping is to be performed.</p>
</dd>
<dt>dx<span class="classifier">float/tuple, default=None</span></dt><dd><p>Amount(s) by which to crop object in x-direction.  If dx
is a float, the object is cropped by this amount on both sides.
If dx is a tuple, the object is cropped on the sides at lower
and higher x by the amounts of the tuple’s first and second
elements.  No cropping is performed for a crop amount set to None.</p>
</dd>
<dt>dy<span class="classifier">float/tuple, default=None</span></dt><dd><p>Amount(s) by which to crop object in y-direction.  If dy
is a float, the object is cropped by this amount on both sides.
If dy is a tuple, the object is cropped on the sides at lower
and higher y by the amounts of the tuple’s first and second
elements.  No cropping is performed for a crop amount set to None.</p>
</dd>
<dt>dz<span class="classifier">float/tuple, default=None</span></dt><dd><p>Amount(s) by which to crop object in z-direction.  If dz
is a float, the object is cropped by this amount on both sides.
If dz is a tuple, the object is cropped on the sides at lower
and higher z by the amounts of the tuple’s first and second
elements.  No cropping is performed for a crop amount set to None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.default_aspect">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">default_aspect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.default_aspect" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.downsample">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">downsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.downsample" title="Permalink to this definition"></a></dt>
<dd><p>Downsample an array by the factors specified in &lt;dx&gt;, &lt;dy&gt;, and &lt;dz&gt;.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.entropy">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.entropy" title="Permalink to this definition"></a></dt>
<dd><p>Calculate entropy for variable(s) from probability distribution.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>p<span class="classifier">numpy.array</span></dt><dd><p>One-dimensional numpy array representing the probabilities of
different values of a random variable, or the joint probabilities
of different combinations ov values of a set of random variables.</p>
</dd>
<dt>base<span class="classifier">int/None, default=2</span></dt><dd><p>Base to use when taking logarithms.  If None, use base e.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_alignment_strategy">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_alignment_strategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_alignment_strategy" title="Permalink to this definition"></a></dt>
<dd><p>Extract information defining strategy for image alignment.</p>
<dl class="simple">
<dt>alignment<span class="classifier">tuple/dict/str, default=None</span></dt><dd><p>Strategy to be used for image alignment.  For defailts,
see documentation of skrt.image.get_alignment_translation().</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_alignment_translation">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_alignment_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_alignment_translation" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning &lt;im1&gt; to &lt;im2&gt;, based on &lt;alignment&gt;.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1<span class="classifier">skrt.image.Image</span></dt><dd><p>Image that is to be translated to achieve the alignment.</p>
</dd>
<dt>im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with which alignment is to be performed.</p>
</dd>
<dt>alignment<span class="classifier">tuple/dict/str, default=None</span></dt><dd><p>Strategy to be used for image alignment.  This can be
translation-based, image-based or ROI-based.</p>
</dd>
</dl>
<ul>
<li><p>Translation-based initial alignment:
This is specified by:
- A tuple indicating the amounts (dx, dy, dz) by which a</p>
<blockquote>
<div><p>point in &lt;im1&gt; must be translated to align with
the corresponding point in &lt;im2&gt;;</p>
</div></blockquote>
</li>
<li><p>Image-based alignment:
This can be specified by:
- A dictionary indicating how &lt;im1&gt; and &lt;im2&gt; are</p>
<blockquote>
<div><p>to be aligned along each axis, where keys are axis
identifiers (‘x’, ‘y’, ‘z’), and values are the types
of alignment:
- 1: align on lowest coordinates (right, posterior, inferior);
- 2: align on centre coodinates;
- 3: align on highest coordinates (left, anterior, superior).
If an axis isn’t included in the dictionary, or is included
with an invalid alignment type, the alignment type defaults to 2.</p>
</div></blockquote>
<ul class="simple">
<li><p>One of the strings “_top_”, “_centre_”, “_bottom_”,
in which case &lt;im1&gt; and &lt;im2&gt; have their (x, y)
centres aligned, and have z positions aligned at
image top, centre or bottom.</p></li>
</ul>
</li>
<li><p>ROI-based alignment:
This defines a translation of &lt;im1&gt; so that an ROI associated
with &lt;im1&gt; is aligned with an ROI associated with &lt;im2&gt;.  For
each image, the alignment point is defined by an ROI name and an
optional position.  If the optional position is omitted
or is None, the alginment point is the centroid of the
ROI as a whole.  Otherwise, the alignment point is the
centroid of an (x, y) slice through the ROI at the
specified relative position along the z-axis.  This
relative position must be in the interval [0, 1], where
0 corresponds to the most-inferior point (lowest z) and
1 corresponds to the most-superior point (highest z).</p>
<p>The full ROI-based alignment specification is a
tuple of two two-element tuples:
((“im1_roi_name”, im1_roi_position),
(“im2_roi_name”, im2_roi_position)).
If a position is omitted, it defaults to None, and the
ROI name can be given either as a string or as a
one-element tuple.  If information is given only for
&lt;im1&gt;, the same information is used for &lt;im2&gt;.</p>
<p>The following are examples of valid ROI-based alignment
specifications, and how they’re interpreted:</p>
<ul class="simple">
<li><p>“roi”:
align “roi” of &lt;im1&gt; with “roi” of &lt;im2&gt;,
aligning on volume centroids;</p></li>
<li><p>(“roi1”, “roi2”):
align “roi1” of &lt;im1&gt; with “roi2” of &lt;im2&gt;,
aligning on volume centroids;</p></li>
<li><p>(“roi”, 1):
align “roi” of &lt;im1&gt; with “roi” of &lt;im2&gt;,
aligning on centroids of top slices;</p></li>
<li><p>((“roi1”, 0.75), “roi2”):
align “roi1” of &lt;im1&gt; with “roi2” of &lt;im2&gt;,
aligning centroid of slice three quarters of the way
up “roi1” with the volume centroid of “roi2”.</p></li>
</ul>
<p>Note that ROI-based alignment relies on the named
ROIs being contained in structure sets associated with
&lt;im1&gt; and &lt;im2&gt;.  Association of structure sets
to images may be performed automatically when loading
DICOM data to Patient objects, or may be performed
manually using an Image object’s set_structure_set() method.</p>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_box_mask_from_mask">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_box_mask_from_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_box_mask_from_mask" title="Permalink to this definition"></a></dt>
<dd><p>Slice by slice, create box masks enclosing an arbitrarily shaped mask.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>image<span class="classifier">Image, default=None</span></dt><dd><p>Image object representing arbitrarily shaped mask for which
slice-by-slice box masks are to be determined.</p>
</dd>
<dt>dx<span class="classifier">int, default=0</span></dt><dd><p>Margin along columns to be added on each side of mask bounding box.</p>
</dd>
<dt>dy<span class="classifier">int, default=0</span></dt><dd><p>Margin along rows to be added on each side of mask bounding box.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_dicom_affine">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_dicom_affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_positions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_dicom_affine" title="Permalink to this definition"></a></dt>
<dd><p>Assemble affine matrix from a dicom file. Optionally infer slice 
thickness from the positions of different slices and origin from the 
minimum slice; otherwise, extract slice thickness and origin directly from 
the dicom dataset.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dicom dataset from which to load voxel sizes.</p>
</dd>
<dt>image_positions<span class="classifier">dict, default=None</span></dt><dd><p>Dict of 3D origins for each slice, where keys are slice positions
and values are origins.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>affine<span class="classifier">np.ndarray</span></dt><dd><p>3x3 array containing the affine matrix for this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_dicom_orientation">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_dicom_orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_dicom_orientation" title="Permalink to this definition"></a></dt>
<dd><p>Extract and parse image orientation from a dicom file.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dicom dataset object from which the orientation vector should be read.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>orientation: np.ndarray</dt><dd><p>Direction cosines of the first row and first column, reshaped to (2, 3)
such that the top row of the array contains the row direction cosine,
and the bottom row contains the column direction cosine.</p>
</dd>
<dt>axes<span class="classifier">list</span></dt><dd><p>List of the axes (x = 0, y = 1, z = 2) corresponding to each image
array axis in order [row, column, slice].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_dicom_paths">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_dicom_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_dicom_paths" title="Permalink to this definition"></a></dt>
<dd><p>Get list of dicom files correpsonding to a single dicom image.</p>
<p><strong>Parameters</strong>:</p>
<dl>
<dt>path<span class="classifier">str</span></dt><dd><p>Path to either a single dicom file, or a directory containing multiple
dicom files.</p>
<p>If path is a directory, a list of dicom files within that directory will
be returned.</p>
<p>If path is a single file, that file will be opened and its 
ImagesInAcquisition property will be checked.</p>
<blockquote>
<div><ul class="simple">
<li><p>If ImagesInAcquisition == 1, a list containing the single input</p></li>
</ul>
<p>path will be returned. 
- Otherwise, a list containing all the dicom files in the same 
directory as the input file will be returned.</p>
</div></blockquote>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>paths<span class="classifier">list of strs</span></dt><dd><p>List of strings, each pointing to a single dicom file. If no valid
dicom files are found, returns an empty list.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_dicom_voxel_size">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_dicom_voxel_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_dicom_voxel_size" title="Permalink to this definition"></a></dt>
<dd><p>Get voxel sizes from a dicom file.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dicom dataset from which to load voxel sizes.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>voxel_size<span class="classifier">list</span></dt><dd><p>List of voxel sizes in order [row, column, slice].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_dicom_window">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_dicom_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_dicom_window" title="Permalink to this definition"></a></dt>
<dd><p>Get intensity window defaults from a dicom file.</p>
<p><strong>Parameters</strong>:
ds : pydicom.FileDataset</p>
<blockquote>
<div><p>Dicom dataset from which to read intensity window info.</p>
</div></blockquote>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>window_centre<span class="classifier">float</span></dt><dd><p>Default window centre.</p>
</dd>
<dt>window_width<span class="classifier">float</span></dt><dd><p>Default window width.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_geometry">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">affine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_nifti</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_geometry" title="Permalink to this definition"></a></dt>
<dd><p>Get an affine matrix, voxel size list, and origin list from 
a combination of these inputs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_image_comparison_metrics">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_image_comparison_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_image_comparison_metrics" title="Permalink to this definition"></a></dt>
<dd><p>Get list of image-comparison metrics.</p>
<p>This returns the combined list of metrics based on mutual information
(returned by get_mi_metrics()) and quality metrics
(returned by get_quality_metrics()).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_mask">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_to_match</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_mask" title="Permalink to this definition"></a></dt>
<dd><p>Return mask as Image object, with boolean data, resizing if required.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>mask<span class="classifier">Image/list/ROI/str/StructureSet, default=None</span></dt><dd><p>Image object representing a mask or a source from which
an Image object can be initialised.  In addition to the
sources accepted by the Image constructor, the source
may be an ROI, a list of ROIs or a StructureSet.  In the
latter cases, the mask image is derived from the ROI mask(s).</p>
</dd>
<dt>mask_threshold<span class="classifier">float, default=0.5</span></dt><dd><p>Threshold for mask data.  Values above and below this value are
set to True and False respectively.  Taken into account only
if the mask image has non-boolean data.</p>
</dd>
<dt>image_to_match<span class="classifier">Image/str, default=None</span></dt><dd><p>Image object or a source from which an Image object can be
initialised.  The mask will be resized if needed, to match
this image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_mask_bbox">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_mask_bbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_mask_bbox" title="Permalink to this definition"></a></dt>
<dd><p>Obtain bounding box of labelled area of label mask.</p>
<p>The bounding box is returned as [(xmin, xmax), (ymin, ymax), (zmin, zmax)],
with values in mm.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>mask<span class="classifier">skrt.image.Image</span></dt><dd><p>Image object representing label mask for which bounding box is
to be obtained.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_mi_metrics">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_mi_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_mi_metrics" title="Permalink to this definition"></a></dt>
<dd><p>Get list of metrics based on mutual information.</p>
<p>All metrics listed here should be recognised by
Image.get_mutual_information(), and all metrics recognised by
Image.get_mutual_information() should be listed here.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_quality_metrics">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_quality_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_quality_metrics" title="Permalink to this definition"></a></dt>
<dd><p>Get list of metrics measuring quality of one metric relative to another.</p>
<p>All metrics listed here should be recognised by Image.get_quality(),
and all metrics recognised by Image.get_quality() should be listed here.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_translation_to_align">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_translation_to_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_translation_to_align" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning &lt;im1&gt; to &lt;im2&gt;.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1<span class="classifier">skrt.image.Image</span></dt><dd><p>Image that is to be translated to achieve the alignment.</p>
</dd>
<dt>im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with which alignment is to be performed.</p>
</dd>
<dt>alignments<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary indicating how alignment is to be performed along each
axis, where keys are axis identifiers (‘x’, ‘y’, ‘z’), and values
are the types of alignment.  The valid alignment values are:
- 1: align on lowest coordinates (right, posterior, inferior);
- 2: align on centre coodinates;
- 3: align on highest coordinates (left, anterior, superior).
If an axis isn’t included in the dictionary, or is included with
an invalid alignment type, the value of &lt;default_alignment&gt; is
used for this axis.</p>
</dd>
<dt>default_alignment<span class="classifier">int, default=2</span></dt><dd><p>Type of alignment to be applied along any axis not included in
the &lt;alignments&gt; dictionary.</p>
</dd>
<dt>threshold<span class="classifier">int/float, default=None</span></dt><dd><p>If None, alignment is with respect to the whole images.  If an
integer or float, alignment is with respect to the masks
returned for the images by skrt.image.Image.get_foreground_mask(),
using value specified as the threshold parameter for mask creation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.get_translation_to_align_image_rois">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">get_translation_to_align_image_rois</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_name1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_name2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_fraction1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_fraction2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.get_translation_to_align_image_rois" title="Permalink to this definition"></a></dt>
<dd><p>Determine translation for aligning ROI of &lt;im1&gt; to ROI of &lt;im2&gt;.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with linked StructureSet containing ROI to be
translated to achieve the alignment.</p>
</dd>
<dt>im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Image with linked StructureSet containing ROI with
which alignment is to be performed.</p>
</dd>
<dt>roi_name1<span class="classifier">str</span></dt><dd><p>Name of ROI contained in StructureSet linked to &lt;im1&gt;,
and that it to be translated to achieve the alignment.</p>
</dd>
<dt>roi_name2<span class="classifier">str</span></dt><dd><p>Name of ROI contained in StructureSet linked to &lt;im2&gt;,
and with which alignment is to be performed.</p>
</dd>
<dt>z_fraction1<span class="classifier">float, default=None</span></dt><dd><p>For ROI identified by &lt;roi_name1&gt;, position along z axis
of iROI slice on which to align.  If None, alignment is
to the centroid of the whole ROI volume.  Otherwise, alignment
is to the centroid of the slice at the specified distance
from the ROI’s most-inferior point: 0 corresponds to
the most-inferior point (lowest z); 1 corresponds to the
most-superior point (highest z).  Values for z_fraction
outside the interval [0, 1] result in a RuntimeError.</p>
</dd>
<dt>z_fraction2<span class="classifier">float, default=None</span></dt><dd><p>For ROI identified by &lt;roi_name2&gt;, position along z axis
of ROI slice on which to align.  If None, alignment is
to the centroid of the whole ROI volume.  Otherwise, alignment
is to the centroid of the slice at the specified distance
from the ROI’s most-inferior point: 0 corresponds to
the most-inferior point (lowest z); 1 corresponds to the
most-superior point (highest z).  Values for z_fraction
outside the interval [0, 1] result in a RuntimeError.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.kv_to_mv">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">kv_to_mv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.kv_to_mv" title="Permalink to this definition"></a></dt>
<dd><p>Map radiodensity in Hounsfield units from kV CT scan to MV CT scan.</p>
<p>Function originally written by M.Z. Wilson.  Parameterisation
derived from kV and MV CT scans collected in VoxTox study.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>hu - int</dt><dd><p>Radiodensity (Hounsfield units) for kV CT scan.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_dicom">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_dicom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_dicom" title="Permalink to this definition"></a></dt>
<dd><p>Load a dicom image from one or more dicom files.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>paths<span class="classifier">str/list</span></dt><dd><p>Path to a single dicom file, path to a directory containing multiple
dicom files, or list of paths to dicom files. If path points to a
single file that is found to be part of a series of multiple dicom
files corresponding to one image,  the image will be loaded from
all dicom files in the same directory as the first that match its
StudyInstanceUID and SeriesNumber.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>data<span class="classifier">np.ndarray</span></dt><dd><p>Numpy array containing the voxel intensities for the image.</p>
</dd>
<dt>affine<span class="classifier">np.ndarray</span></dt><dd><p>3x3 numpy array containing the affine matrix.</p>
</dd>
<dt>window_centre<span class="classifier">float</span></dt><dd><p>Default intensity window centre for viewing this image.</p>
</dd>
<dt>window_width<span class="classifier">float</span></dt><dd><p>Default intensity window width for viewing this image.</p>
</dd>
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dicom dataset corresponding to the last file loaded.</p>
</dd>
<dt>z_paths<span class="classifier">dict / None</span></dt><dd><p>Dictionary mapping z slice positions in mm to the file corresponding to 
that slice. If image was loaded from a single file, this will be None.</p>
</dd>
<dt>z_instance_numbers<span class="classifier">dict / None</span></dt><dd><p>Dictionary mapping z slice positions in mm to the instance number of
that slice. If image was loaded from a single file, this will be None.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_dicom_many_files">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_dicom_many_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">paths</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_dicom_many_files" title="Permalink to this definition"></a></dt>
<dd><p>Load an image array from multiple dicom files and use the spacing 
between slices to determine the slice thickness.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>paths<span class="classifier">list of strs</span></dt><dd><p>List of paths to the dicom files from which the image should be loaded.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>image<span class="classifier">np.ndarray</span></dt><dd><p>Numpy array containing image data.</p>
</dd>
<dt>affine<span class="classifier">np.ndarray</span></dt><dd><p>3x3 numpy array containing affine matrix.</p>
</dd>
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dataset object corresponding to the last file loaded.</p>
</dd>
<dt>z_paths<span class="classifier">dict</span></dt><dd><p>Dict mapping z slice positions in mm  to the filepath 
from which that slice of the image was read.</p>
</dd>
<dt>z_instance_numbers<span class="classifier">dict</span></dt><dd><p>Dict mapping z slice positions in mm  to the instance
number of that slice of the image.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_dicom_single_file">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_dicom_single_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_dicom_single_file" title="Permalink to this definition"></a></dt>
<dd><p>Load an image array from a single dicom file.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>path<span class="classifier">str</span></dt><dd><p>Path to the dicom file from which the image should be loaded.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>image<span class="classifier">np.ndarray</span></dt><dd><p>Numpy array containing image data.</p>
</dd>
<dt>affine<span class="classifier">np.ndarray</span></dt><dd><p>3x3 numpy array containing affine matrix.</p>
</dd>
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dataset object corresponding to the dicom file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_nifti">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_nifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_nifti" title="Permalink to this definition"></a></dt>
<dd><p>Load an image from a nifti file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_npy">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_npy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_npy" title="Permalink to this definition"></a></dt>
<dd><p>Load a numpy array from a .npy file.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.load_rgb">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">load_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.299,</span> <span class="pre">0.587,</span> <span class="pre">0.114)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_slope</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_rescale_intercept</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.load_rgb" title="Permalink to this definition"></a></dt>
<dd><p>Load an rgb image with the Python Imaging Library (PIL),
and convert to grey levels.</p>
<p><strong>Parameter:</strong></p>
<dl>
<dt>rgb_weights<span class="classifier">tuple, default=(0.299, 0.587, 0.114)</span></dt><dd><p>Three-element tuple specifying the weights to red (R),
green (G), blue (B) channels to arrive at a grey level:</p>
<p>L = R * rgb[0] + G * rgb[1] + B * rgb[2]</p>
<p>The default is the same as the PIL default:
<a class="reference external" href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert">https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert</a></p>
</dd>
<dt>rgb_rescale_slope: float, default=100</dt><dd><p>Factor by which to multiply grey level in rescaling.</p>
</dd>
<dt>rgb_rescale_intercept: float, default=0</dt><dd><p>Constant to add to multiplied grey level in rescaling.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.match_image_voxel_sizes">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">match_image_voxel_sizes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.match_image_voxel_sizes" title="Permalink to this definition"></a></dt>
<dd><p>Resample pair of images to same voxel size.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1, im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Images to resample.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple/str/float, default=None</span></dt><dd><p>Specification of voxel size for image resampling.
Possible values are:</p>
<ul class="simple">
<li><p>None: no resampling performed;</p></li>
<li><p>“dz_max”: the image with smaller slice thickness is resampled
to have the same voxel size as the image with larger
slice thickness;</p></li>
<li><p>“dz_min”: the image with larger slice thickness is resampled
to have the same voxel size as the image with smaller
slice thickness;</p></li>
<li><p>(dx, dy, dz): both images are resampled, to have voxels with the
specified dimensions in mm.</p></li>
<li><p>dxyz: both images are resampled, to have voxels with the
specified dimension in mm along all axes.</p></li>
</ul>
</dd>
<dt>order: int, default = 1</dt><dd><p>Order of the b-spline used in interpolating voxel intensity values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.match_images">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">match_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2_crop_focus</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2_crop_margins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2_crop_about_centre</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.match_images" title="Permalink to this definition"></a></dt>
<dd><p>Process pair of images, so that they match in one or more respects.</p>
<p>Matching can be with respect to image size, voxel size,
grey-level banding, and/or ROI naming in associated structure sets.
The returned images are created from clones of the input images,
which are left unchanged.</p>
<p>The second ROI of the pair may be cropped about a focus (ROI or point).
The first ROI of the pair may be cropped to the size of the first.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1, im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Images to be matched with one another.</p>
</dd>
<dt>ss1, ss2<span class="classifier">skrt.structures.StructureSet, default=None</span></dt><dd><p>Structure sets to associate with images im1, im2.  If a value
is None, and image matching involves ROI alignment, a structure
set already associated with the relevant image is used
(im1.structure_sets[ss1_index], im2.structure_sets[ss2_index]).</p>
</dd>
<dt>ss1_index, ss2_index<span class="classifier">int, default=-1</span></dt><dd><p>Structure set indices to use for ROI alignment based on
structure sets already associated with images.</p>
</dd>
<dt>ss1_name, ss2_name<span class="classifier">str, default=None</span></dt><dd><p>Names to be assigned to structure sets associated with the
returned image objects.  If a value is None, the original
name is kept.</p>
</dd>
<dt>roi_names<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary for renaming and filtering ROIs for inclusion
in the structure sets associated with the output images.
Keys are names for ROIs to be kept, and values are lists of
alternative names with which these ROIs may have been
labelled in the input structure sets.  The alternative names
can contain wildcards with the ‘*’ symbol.  If a value of
None is given, all ROIs in the input structure sets are kept,
with no renaming.</p>
</dd>
<dt>im2_crop_focus<span class="classifier">str/tuple, default=None</span></dt><dd><p>Name of an ROI, or (x, y, z) coordinates of a point, about
which to perform cropping of im2.  If None, cropping is performed
about the point (0, 0, 0) if im2_crop_margins is non-null, or
otherwise no cropping is performed.</p>
</dd>
<dt>im2_crop_margins, float/tuple, default=None</dt><dd><p>Specification of margin around focus for cropping of im2.
For information on specifying crop margins for the case where
im2_crop_focus is the name of an ROI, see documentation for
method skrt.image.Image.crop_to_roi(). For the case where
im2_crop_focus is a point coordinate, margins should be
sepecified by a tuple (xlim, ylim, zlim).  Here, xlim, ylim, zlim
are two-component tuples specifying lower and upper bounds
relative to the crop point.</p>
</dd>
<dt>im2_crop_about_centre: bool, default=False</dt><dd><p>For the case where im2_crop_focus is the name of an ROI:
if True, im2 is cropped to the centre point of the ROI plus margins;
if False, im2 is cropped to the ROI extents plus margins.
Ignored for the case where im2_crop_focus isn’t the name of an ROI.</p>
</dd>
<dt>alignment<span class="classifier">tuple/dict/str, default=None</span></dt><dd><p>Strategy to be used for aligning images prior to cropping
so that they have the same size.  For strategy details, see
documentation of skrt.image.get_alignment_translation().
After alignment, im1 is cropped to the size of im2, then im2
is cropped to the size of im1.  To omit cropping to the same
size, set alginment to False.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple/str/float, default=None</span></dt><dd><p>Specification of voxel size for image resampling.
For possible values, see documentation for function
skrt.image.match_image_voxel_size().</p>
</dd>
<dt>bands - dict, default=None</dt><dd><p>Dictionary of value bandings to be applied to image data.
Keys specify band limits, and values indicte the values
to be assigned.  For more information, see documentation of
method skrt.image.Image.apply_banding().</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.match_images_for_comparison">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">match_images_for_comparison</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss1_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss2_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roi_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.match_images_for_comparison" title="Permalink to this definition"></a></dt>
<dd><p>Process pair of images, to allow their comparison.</p>
<p>Images are optionally aligned, then their geometries are matched,
so that they can be handled by the image-comparison methods
Image.get_comparison() and Image.get_quality().</p>
<p>This function provides a subset of the processing options offered
by match_images(), and in addition can change the origin of the first
image, to align better with the second image.</p>
<p><strong>Parameters:</strong></p>
<dl class="simple">
<dt>im1, im2<span class="classifier">skrt.image.Image</span></dt><dd><p>Images to be matched for comparison.</p>
</dd>
<dt>ss1, ss2<span class="classifier">skrt.structures.StructureSet, default=None</span></dt><dd><p>Structure sets to associate with images im1, im2.  If a value
is None, and image matching involves ROI alignment, a structure
set already associated with the relevant image is used
(im1.structure_sets[ss1_index], im2.structure_sets[ss2_index]).</p>
</dd>
<dt>ss1_index, ss2_index<span class="classifier">int, default=-1</span></dt><dd><p>Structure set indices to use for ROI alignment based on
structure sets already associated with images.</p>
</dd>
<dt>ss1_name, ss2_name<span class="classifier">str, default=None</span></dt><dd><p>Names to be assigned to structure sets associated with the
returned image objects.  If a value is None, the original
name is kept.</p>
</dd>
<dt>roi_names<span class="classifier">dict, default=None</span></dt><dd><p>Dictionary for renaming and filtering ROIs for inclusion
in the structure sets associated with the output images.
Keys are names for ROIs to be kept, and values are lists of
alternative names with which these ROIs may have been
labelled in the input structure sets.  The alternative names
can contain wildcards with the ‘*’ symbol.  If a value of
None is given, all ROIs in the input structure sets are kept,
with no renaming.</p>
</dd>
<dt>alignment<span class="classifier">tuple/dict/str, default=None</span></dt><dd><p>Strategy to be used for aligning images prior to cropping
so that they have the same size.  For strategy details, see
documentation of skrt.image.get_alignment_translation().
After alignment, im1 is cropped to the size of im2, then im2
is cropped to the size of im1.  To omit cropping to the same
size, set alginment to False.</p>
</dd>
<dt>voxel_size<span class="classifier">tuple/str/float, default=None</span></dt><dd><p>Specification of voxel size for image resampling.
For possible values, see documentation for function
skrt.image.match_image_voxel_size().</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.pad_transpose">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">pad_transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transpose</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.pad_transpose" title="Permalink to this definition"></a></dt>
<dd><p>Pad a transpose vector to match a given number of dimensions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.remove_duplicate_images">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">remove_duplicate_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.remove_duplicate_images" title="Permalink to this definition"></a></dt>
<dd><p>Remove duplicates from a list of image objects.</p>
<p>Image instance image1 is taken to be a duplicate of image2 if
image1.has_same_data(image2) is True.</p>
<p><strong>Parameter:</strong>
images: list, default=None</p>
<blockquote>
<div><p>List of image objects, from which duplicates are to be removed.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.rescale_dicom_data">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">rescale_dicom_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.rescale_dicom_data" title="Permalink to this definition"></a></dt>
<dd><p>Rescale an array according to rescaling info in a dicom dataset.</p>
<p><strong>Parameters</strong>:</p>
<dl class="simple">
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>Dicom dataset from which to read rescaling info.</p>
</dd>
<dt>data<span class="classifier">np.ndarray</span></dt><dd><p>Image array to be rescaled.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>data<span class="classifier">np.ndarray</span></dt><dd><p>Rescaled version of the input array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.rescale_images">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">rescale_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.rescale_images" title="Permalink to this definition"></a></dt>
<dd><p>For one or more images, linearly rescale greyscale values
so that they span a specified range.</p>
<p>Returns the input images if no rescaling is performed.  Otherwise
returns the input images rescaled (&lt;clone&gt; set to False) or
rescaled clones of the input images (&lt;clone&gt; set to True).</p>
<dl>
<dt>image<span class="classifier">list</span></dt><dd><p>List of skrt.image.Image objects, for which rescaling
is to be performed.</p>
<dl class="simple">
<dt>v_min: float, default=0.0</dt><dd><p>Minimum greyscale value after rescaling.  If None,
no rescaling is performed.</p>
</dd>
<dt>v_max: float, default=1.0</dt><dd><p>Maximum greyscale value after rescaling.  If None,
no rescaling is performed.</p>
</dd>
<dt>constant: float, default=0.5</dt><dd><p>Greyscale value to assign after rescaling if all values
in the original image are the same.  If None,
original value is kept.</p>
</dd>
</dl>
</dd>
<dt>clone<span class="classifier">bool, default=True</span></dt><dd><p>If True, clone each input image before rescaling.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.set_ax">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">set_ax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gs=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aspect_getter=&lt;function</span> <span class="pre">default_aspect&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.set_ax" title="Permalink to this definition"></a></dt>
<dd><p>Set up axes for plotting an object, either from a given exes or
gridspec, or by creating new axes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.set_image_orientation_patient">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">set_image_orientation_patient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.set_image_orientation_patient" title="Permalink to this definition"></a></dt>
<dd><p>Try to ensure that image orientation patient is set for DICOM dataset.</p>
<p>If the dataset doesn’t have the attribute ImageOrientationPatient,
the effective value is determined from PatientOrientation, if present.</p>
<p><strong>Parameter:</strong></p>
<dl class="simple">
<dt>ds<span class="classifier">pydicom.FileDataset</span></dt><dd><p>DICOM dataset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.sum_images">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">sum_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">images</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.sum_images" title="Permalink to this definition"></a></dt>
<dd><p>Sum images of the same geometry.</p>
<p>If not all images have the same same geometry (shape, origin,
voxel size), None is returned.  Otherwise, an Image object is
returned that has the same geometry as the input images, and
where array values are the sums of the array values of
the input images.</p>
<p><strong>Parameter:</strong>
images: list, default=None</p>
<blockquote>
<div><p>List of Image objects to be summed.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.to_inches">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">to_inches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.to_inches" title="Permalink to this definition"></a></dt>
<dd><p>Convert a size string to a size in inches. If a float is given, it will
be returned. If a string is given, the last two characters will be used to
determine the units:</p>
<blockquote>
<div><ul class="simple">
<li><p>‘in’: inches</p></li>
<li><p>‘cm’: cm</p></li>
<li><p>‘mm’: mm</p></li>
<li><p>‘px’: pixels</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.write_nifti">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">write_nifti</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.write_nifti" title="Permalink to this definition"></a></dt>
<dd><p>Create a nifti file at &lt;outname&gt; containing &lt;data&gt; and &lt;affine&gt;.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="skrt.image.write_npy">
<span class="sig-prename descclassname"><span class="pre">skrt.image.</span></span><span class="sig-name descname"><span class="pre">write_npy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#skrt.image.write_npy" title="Permalink to this definition"></a></dt>
<dd><p>Create numpy file containing data. If &lt;affine&gt; is not None, voxel
sizes and origin will be written to a text file.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="skrt.dose.html" class="btn btn-neutral float-left" title="skrt.dose module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="skrt.multi.html" class="btn btn-neutral float-right" title="skrt.multi module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>